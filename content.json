{"meta":{"title":"Shown的部落阁","subtitle":null,"description":"用简洁的语言形容繁杂的配置","author":"Shown Feng","url":""},"pages":[{"title":"","date":"2020-05-15T12:11:32.147Z","updated":"2020-05-15T12:11:32.147Z","comments":true,"path":"baidu_verify_KnwO5ZjAAf.html","permalink":"/baidu_verify_KnwO5ZjAAf.html","excerpt":"","text":"KnwO5ZjAAf"},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"weChan","date":"2018-12-20T15:13:35.000Z","updated":"2020-05-15T05:56:09.983Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"更多分享关注下面公众号：","keywords":"微信公众号"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2020-05-12T07:15:43.000Z","updated":"2020-05-12T07:20:45.596Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"tools","date":"2020-05-14T03:22:15.000Z","updated":"2020-05-14T04:36:11.022Z","comments":true,"path":"tools/index.html","permalink":"/tools/index.html","excerpt":"","text":"自用windows小工具集合idm下载神器(绿色版)下载链接：https://ww.lanzous.com/iclrghi win64位视频播放器(potplay强大的解码能力)下载链接：https://ww.lanzous.com/iclrhcj 文件索引工具(uTools快速查找文件,还有各种插件)下载链接：https://ww.lanzous.com/iclrh5c 开源免费的截图贴图工具(Snipaste)下载链接：https://ww.lanzous.com/iclrgne 录制gif图神器(Screen To Gif)下载链接：https://ww.lanzous.com/iclrglc 资源管理器管理插件和clover属于同一类的(QTTabBar)下载链接：https://ww.lanzous.com/iclrgkb 轻巧便携的markdown文件编辑器(MarkdownEditor)下载链接：https://ww.lanzous.com/iclrgij win10任务栏透明美化(直接拖进启动文件中’shell:start’)下载链接：https://ww.lanzous.com/iclrz3i 扒自360的截图软件(直接是执行文件)下载链接：https://ww.lanzous.com/iclrz2h AutoHotKey 快捷键或字符串无差别触发的脚本编辑器以及自用的脚本ahk编辑器的官网下载地址https://www.autohotkey.com/自用脚本下载地址：https://ww.lanzous.com/iclsnsh 图片压缩大师(绿色版)下载地址：https://ww.lanzous.com/iclt0re ftp客户端连接工具(FileZilla)下载地址：https://ww.lanzous.com/icltana winscp传送文件应用下载地址：https://ww.lanzous.com/iclte2d"},{"title":"tree","date":"2020-05-11T14:33:38.000Z","updated":"2020-05-13T14:05:32.700Z","comments":true,"path":"tree/index.html","permalink":"/tree/index.html","excerpt":"","text":"村上春树 每个人心里都有一个树洞 你要做一个不动声色的大人了。不准情绪化，不准偷偷想念，不准回头看。去过自己另外的生活。你要听话，不是所有的鱼都会生活在同一片海里。 哪里会有人喜欢孤独，不过是不喜欢失望罢了。 我一直以为人是慢慢变老的，其实不是，人是一瞬间变老的。 每个人都有属于自己的一片森林，也许我们 从来不曾去过，但它一直在那里，总会在那里。迷失的人迷失了，相逢的人会再相逢。 不管全世界所有人怎么说，我都认为自己的感受才是正确的。无论别人怎么看，我绝不打乱自己的节奏。喜欢的事自然可以坚持，不喜欢怎么也长久不了。 刚刚好，看见你幸福的样子，于是幸福着你的幸福。 希望你可以记住我，记住我这样活过，这样在你身边呆过。 总之岁月漫长，然而值得等待 “最最喜欢你，绿子。”“什么程度？”“像喜欢春天的熊一样。”“春天的熊？”绿子再次扬起脸，“什么春天的熊？”“春天的原野里，你一个人正走着，对面走来一只可爱的小熊，浑身的毛活像天鹅绒，眼睛圆鼓鼓的。它这么对你说到：‘你好，小姐，和我一块打滚玩好么？’接着，你就和小熊抱在一起，顺着长满三叶草的山坡咕噜咕噜滚下去，整整玩了一大天。你说棒不棒？”“太棒了。”“我就这么喜欢你。” If you’re in pitch blackness, all you can do is sitting tight until your eyes get used to the dark.如果你掉进了黑暗里，你能做的，不过是静心等待，直到你的双眼适应黑暗。 https://cdn.jsdelivr.net/gh/shinianzaijian/cdn/"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"小白算法记","slug":"小白算法记","date":"2022-02-10T14:56:34.000Z","updated":"2022-02-10T15:57:06.219Z","comments":true,"path":"null/小白算法记/","link":"","permalink":"/null/小白算法记/","excerpt":"","text":"算法记（一）时隔一年多，从求学到求生，经过了一段时间的工作，从当初的忙于应付工作，到现在的游刃有余，从最初对生活充满信心到迷茫，在此，我十分感谢，在我生活工作当中帮助过我或者陪我聊了很多的朋友，张静姐，牛涛哥，杨哥，亚楠姐，在我最迷茫无助的时候和我聊了很多，让我重新沉下心来思考。还要感谢我的老师周宇宁，让我重新记起了原来的自己。 二叉树的中序后序前序遍历废话不多说，先贴上代码1.递归方式 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { List&lt;Integer&gt; ans; public List&lt;Integer&gt; preorderTraversal(TreeNode root) { ans = new ArrayList&lt;Integer&gt;(); dfs(root, ans); return ans; } public void dfs(TreeNode root, List&lt;Integer&gt; ans){ if(root == null){ return; } ans.add(root.val); dfs(root.left, ans); dfs(root.right, ans); } } 递归方式的核心就是分解成最小化问题。分治思想。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"阅读","slug":"阅读","permalink":"/tags/阅读/"},{"name":"算法","slug":"算法","permalink":"/tags/算法/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"设计模式-动态代理","slug":"设计模式-动态代理","date":"2020-05-22T04:54:50.000Z","updated":"2020-05-22T05:54:35.171Z","comments":true,"path":"sjms/设计模式-动态代理/","link":"","permalink":"/sjms/设计模式-动态代理/","excerpt":"","text":"设计模式-动态代理简介 动态代理是Java语言中非常经典的一种设计模式，也是所有设计模式中最难理解的一种。本文将通过一个简单的例子模拟JDK动态代理实现，让你彻底明白动态代理设计模式的本质，文章中可能会涉及到一些你没有学习过的知识点或概念。如果恰好遇到了这些知识盲点，请先去学习这部分知识，再来阅读这篇文章。 什么是代理从字面意思来看，代理比较好理解，无非就是代为处理的意思。举个例子，你在上大学的时候，总是喜欢逃课。因此，你拜托你的同学帮你答到，而自己却窝在宿舍玩游戏… 你的这个同学恰好就充当了代理的作用，代替你去上课。 是的，你没有看错，代理就是这么简单！ 理解了代理的意思，你脑海中恐怕还有两个巨大的疑问： 怎么实现代理模式？ 继承 聚合 代理模式有什么实际用途？ 例如：在方法执行前后记录日志 继承方式实现动态代理 创建一个飞行类，在执行方法前后分别记录一个随机的时间，并且在执行方法后输出所需要的时间 // 接口类 public interface Flyable { void fly(); } // 实现类 public class Bird implements Flyable { @Override public void fly() { System.out.println(&quot;Bird is flying...&quot;); try { Thread.sleep(new Random().nextInt(1000)); } catch (InterruptedException e) { e.printStackTrace(); } } } 以继承的方式添加记录新建bird2类 public class Bird2 extends Bird { @Override public void fly() { long start = System.currentTimeMillis(); super.fly(); long end = System.currentTimeMillis(); System.out.println(&quot;Fly time = &quot; + (end - start)); } } 问题：使用该方式如果要是在飞行前后新增日志打印，可以再次继承Bird2然后再在父类方法执行前后增加日志的输出操作，如果要是先计算时间，然后再输出日志信息呢？就要用下面的方式 聚合方式实现动态代理 以聚合的方式添加记录新建BirdTimeProxy类 利用了java的多态的特性 public class BirdTimeProxy implements Flyable { private Bird bird; public Bird3(Bird bird) { this.bird = bird; } @Override public void fly() { long start = System.currentTimeMillis(); bird.fly(); long end = System.currentTimeMillis(); System.out.println(&quot;Fly time = &quot; + (end - start)); } } 若要输出日志，只需要建立如下类BirdLogProxy public class BirdLogProxy implements Flyable { private Flyable flyable; public BirdLogProxy(Flyable flyable) { this.flyable = flyable; } @Override public void fly() { System.out.println(&quot;Bird fly start...&quot;); flyable.fly(); System.out.println(&quot;Bird fly end...&quot;); } } 调用方法并运行 先打印日志在输出时间 public static void main(String[] args) { Bird bird = new Bird(); BirdLogProxy p1 = new BirdLogProxy(bird); BirdTimeProxy p2 = new BirdTimeProxy(p1); p2.fly(); } 反过来,这么做也可 public static void main(String[] args) { Bird bird = new Bird(); BirdTimeProxy p2 = new BirdTimeProxy(bird); BirdLogProxy p1 = new BirdLogProxy(p2); p1.fly(); } 这就是简单的静态代理方式，对没错这只是静态代理方式，至于动态代理就是，用一种静态代理方法来实现多种方法的类。显然这里通过反射机制是不能实现的。spring中的jdk动态代理以及cglib动态代理一、原理区别java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。 而cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。 1、如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP2、如果目标对象实现了接口，可以强制使用CGLIB实现AOP 3、如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换 JDK动态代理和CGLIB字节码生成的区别？ （1）JDK动态代理只能对实现了接口的类生成代理，而不能针对类 （2）CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法 因为是继承，所以该类或方法最好不要声明成final JDK动态代理的简单实现 package com.lf.shejimoshi.proxy.jdk; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import com.lf.shejimoshi.proxy.entity.UserManager; import com.lf.shejimoshi.proxy.entity.UserManagerImpl; //JDK动态代理实现InvocationHandler接口 public class JdkProxy implements InvocationHandler { private Object target ;//需要代理的目标对象 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(&quot;JDK动态代理，监听开始！&quot;); Object result = method.invoke(target, args); System.out.println(&quot;JDK动态代理，监听结束！&quot;); return result; } //定义获取代理对象方法 private Object getJDKProxy(Object targetObject){ //为目标对象target赋值 this.target = targetObject; //JDK动态代理只能针对实现了接口的类进行代理，newProxyInstance 函数所需参数就可看出 return Proxy.newProxyInstance(targetObject.getClass().getClassLoader(), targetObject.getClass().getInterfaces(), this); } public static void main(String[] args) { JdkProxy jdkProxy = new JdkProxy();//实例化JDKProxy对象 UserManager user = (UserManager) jdkProxy.getJDKProxy(new UserManagerImpl());//获取代理对象,传入需要代理的接口实现的对象 user.addUser(&quot;admin&quot;, &quot;123123&quot;);//执行新增方法 } } cglib动态代理使用 package com.lf.shejimoshi.proxy.cglib; import java.lang.reflect.Method; import com.lf.shejimoshi.proxy.entity.UserManager; import com.lf.shejimoshi.proxy.entity.UserManagerImpl; import net.sf.cglib.proxy.Enhancer; import net.sf.cglib.proxy.MethodInterceptor; import net.sf.cglib.proxy.MethodProxy; //Cglib动态代理，实现MethodInterceptor接口 public class CglibProxy implements MethodInterceptor { private Object target;//需要代理的目标对象 //重写拦截方法 @Override public Object intercept(Object obj, Method method, Object[] arr, MethodProxy proxy) throws Throwable { System.out.println(&quot;Cglib动态代理，监听开始！&quot;); Object invoke = method.invoke(target, arr);//方法执行，参数：target 目标对象 arr参数数组 System.out.println(&quot;Cglib动态代理，监听结束！&quot;); return invoke; } //定义获取代理对象方法 public Object getCglibProxy(Object objectTarget){ //为目标对象target赋值 this.target = objectTarget; Enhancer enhancer = new Enhancer(); //设置父类,因为Cglib是针对指定的类生成一个子类，所以需要指定父类 enhancer.setSuperclass(objectTarget.getClass()); enhancer.setCallback(this);// 设置回调 Object result = enhancer.create();//创建并返回代理对象 return result; } public static void main(String[] args) { CglibProxy cglib = new CglibProxy();//实例化CglibProxy对象 UserManager user = (UserManager) cglib.getCglibProxy(new UserManagerImpl());//获取代理对象 user.delUser(&quot;admin&quot;);//执行删除方法 } } 以上原理即可解释springboot框架中的@async（）注释的失效之谜","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"设计模式","slug":"设计模式","permalink":"/tags/设计模式/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"springboot初体验","slug":"springboot初体验","date":"2020-05-19T11:27:44.000Z","updated":"2020-05-19T13:30:42.000Z","comments":true,"path":"springboot/springboot初体验/","link":"","permalink":"/springboot/springboot初体验/","excerpt":"","text":"一、springboot快速开始 使用的工具SpringToolsSuit STS的官网 使用maven统一处理jar包 使用快速spring Start Project快速生成springboot项目 二、新建一个springboot项目 打开sts工具，配置好maven的seeting文件夹的位置 点击file-&gt;new-&gt;Spring Start Project 新建页面 然后点击下一步（勾选上spring Web组件） 下一步 点击next-&gt;Finish完成 等待jar包导入完成 Spring文件结构 spring的文件结构 修改的代码位置及内容： &lt;properties&gt; &lt;maven-jar-plugin.version&gt;3.1.1&lt;/maven-jar-plugin.version&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; 新建一个测试Controller 如spring文件结构图，在com.feng.demo下新建一个controller包，并新建controller类命名为：DemoController.java 向里面写入如下测试代码： package com.example.demo.controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; /** * @author Shown * 第一个测试实例跳转 */ @RestController public class DemoController { @RequestMapping(&quot;/index&quot;) public String getIndexPage() { return &quot;This is indexPage!&quot;; } } 运行Demo01Application.java启动类 测试是否返回正确 打开浏览器输入localhost:8080/index 显示如下网页内容,即代表已经运行成功 success 补充 springboot+Thymeleaf（前台数据接收展示）+mybatis-Pluse（mybatis多数据源）+ shiro（安全实现策略）完整后台服务服务层框架","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"springboot","slug":"springboot","permalink":"/tags/springboot/"},{"name":"框架","slug":"框架","permalink":"/tags/框架/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"hyrobort的使用","slug":"hyrobort的使用","date":"2020-05-17T07:32:35.000Z","updated":"2020-05-17T08:03:12.527Z","comments":true,"path":"hyrobort/hyrobort的使用/","link":"","permalink":"/hyrobort/hyrobort的使用/","excerpt":"","text":"准备工作 安装selenium和RobotFramework依赖 下载项目的基本架构 hyrobort官网 公用的lib启动文件 用于打开浏览器以及保存登录状态 from hyrobot.common import * from selenium import webdriver from time import sleep def open_browser(): wd = webdriver.Chrome() wd.implicitly_wait(5) wd.get(&#39;http://127.0.0.1/mgr/sign.html&#39;) // 保存登录状态 GSTORE[&#39;get_glob_web&#39;] = wd return wd def login_byhy(wd): # 根据 ID 选择元素，并且输入字符串 wd.find_element_by_id(&#39;username&#39;).send_keys(&#39;byhy&#39;) wd.find_element_by_id(&#39;password&#39;).send_keys(&#39;88888888&#39;) # 根据标签名查找元素 wd.find_element_by_tag_name(&#39;button&#39;).click() sleep(3) def get_glob_web(): return GSTORE[&#39;get_glob_web&#39;] 用例文件的初始化和清除（共有3种方法）执行顺序如下 自动化框架的初始化和清除执行顺序 首先看第一种： 单个用例的初始化、清除 是在 用例对应的类里面添加setup、teardown 方法 class c1: name = &#39;管理员首页 - UI-0101&#39; # 初始化方法 def setup(self): wd = open_browser() mgr_login(wd) #清除方法 def teardown(self): wd = get_global_webdriver() wd.quit() # 测试用例步骤 def teststeps(self): # 获取webdriver对象 对应 已经登录好的浏览器 wd = get_global_webdriver() STEP(1, &#39;获取左侧菜单信息&#39;) 第二种： 整个 用例文件 的初始化、清除 是在 文件中 添加全局函数 suite_setup、suite_teardown from hyrobot.common import * from lib.webui import * from time import sleep def suite_setup(): INFO(&#39;suite_setup&#39;) wd = open_browser() mgr_login(wd) def suite_teardown(): INFO(&#39;suite_teardown&#39;) wd = get_global_webdriver() wd.quit() class c1: # 测试用例名字 name = &#39;管理员首页 - UI-0101&#39; # 测试用例步骤 def teststeps(self): wd = get_global_webdriver() STEP(1, &#39;获取左侧菜单信息&#39;) ... STEP(2, &#39;检查是否正确&#39;) ... class c2: name = &#39;管理员首页 - UI-0102&#39; # 测试用例步骤 def teststeps(self): wd = get_global_webdriver() STEP(1, &#39;点击左侧客户菜单&#39;) ... STEP(2, &#39;添加客户&#39;) ... STEP(3, &#39;检查添加信息&#39;) ... # 预期内容为 ... CHECK_POINT(&#39;客户信息和添加内容一致 &#39;, texts == expected) 第三种： 套件目录的初始化、清除，就是 在这个目录下面创建名为 st.py 的文件，也是在 文件中 添加全局函数 suite_setup、suite_teardown。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"},{"name":"自动化","slug":"自动化","permalink":"/tags/自动化/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"selenium快速使用","slug":"selenium快速使用","date":"2020-05-17T07:13:16.000Z","updated":"2020-05-17T07:23:45.472Z","comments":true,"path":"selenium/selenium快速使用/","link":"","permalink":"/selenium/selenium快速使用/","excerpt":"","text":"selenium的快速使用from selenium import webdriver wd = webdriver.Chrome() // 设置超时时间 wd.implicitly_wait(10) // 设置打来网址 wd.get(&#39;http://www.51job.com&#39;) // 选择器定位元素 element = wd.find_element_by_id(&#39;work_position_input&#39;) element.click() elements = wd.find_elements_by_css_selector(&#39;#work_position_click_center_right em.on&#39;) for element in elements: element.click() wd.find_element_by_id(&#39;work_position_click_center_right_list_category_000000_010000&#39;).click() wd.find_element_by_id(&#39;work_position_click_bottom_save&#39;).click() wd.find_element_by_id(&#39;kwdselectid&#39;).send_keys(&#39;自动化测试工程\\n&#39;) // 接收标签中的内容 elements = wd.find_elements_by_css_selector(&#39;div.dw_table &gt; div.el&#39;) for element in elements: print(element.text) // 退出 wd.quit()","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"},{"name":"自动化测试","slug":"自动化测试","permalink":"/tags/自动化测试/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"web开发中用到的工具类","slug":"web开发中用到的工具类","date":"2020-05-17T06:56:58.000Z","updated":"2020-05-17T07:08:21.066Z","comments":true,"path":"webtools/web开发中用到的工具类/","link":"","permalink":"/webtools/web开发中用到的工具类/","excerpt":"","text":"CookieUtils.javapackage com.taotao.common.utils; import java.io.UnsupportedEncodingException; import java.net.URLDecoder; import java.net.URLEncoder; import javax.servlet.http.Cookie; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; /** * * Cookie 工具类 * */ public final class CookieUtils { /** * 得到Cookie的值, 不编码 * * @param request * @param cookieName * @return */ public static String getCookieValue(HttpServletRequest request, String cookieName) { return getCookieValue(request, cookieName, false); } /** * 得到Cookie的值, * * @param request * @param cookieName * @return */ public static String getCookieValue(HttpServletRequest request, String cookieName, boolean isDecoder) { Cookie[] cookieList = request.getCookies(); if (cookieList == null || cookieName == null) { return null; } String retValue = null; try { for (int i = 0; i &lt; cookieList.length; i++) { if (cookieList[i].getName().equals(cookieName)) { if (isDecoder) { retValue = URLDecoder.decode(cookieList[i].getValue(), &quot;UTF-8&quot;); } else { retValue = cookieList[i].getValue(); } break; } } } catch (UnsupportedEncodingException e) { e.printStackTrace(); } return retValue; } /** * 得到Cookie的值, * * @param request * @param cookieName * @return */ public static String getCookieValue(HttpServletRequest request, String cookieName, String encodeString) { Cookie[] cookieList = request.getCookies(); if (cookieList == null || cookieName == null) { return null; } String retValue = null; try { for (int i = 0; i &lt; cookieList.length; i++) { if (cookieList[i].getName().equals(cookieName)) { retValue = URLDecoder.decode(cookieList[i].getValue(), encodeString); break; } } } catch (UnsupportedEncodingException e) { e.printStackTrace(); } return retValue; } /** * 设置Cookie的值 不设置生效时间默认浏览器关闭即失效,也不编码 */ public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue) { setCookie(request, response, cookieName, cookieValue, -1); } /** * 设置Cookie的值 在指定时间内生效,但不编码 */ public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue, int cookieMaxage) { setCookie(request, response, cookieName, cookieValue, cookieMaxage, false); } /** * 设置Cookie的值 不设置生效时间,但编码 */ public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue, boolean isEncode) { setCookie(request, response, cookieName, cookieValue, -1, isEncode); } /** * 设置Cookie的值 在指定时间内生效, 编码参数 */ public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue, int cookieMaxage, boolean isEncode) { doSetCookie(request, response, cookieName, cookieValue, cookieMaxage, isEncode); } /** * 设置Cookie的值 在指定时间内生效, 编码参数(指定编码) */ public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue, int cookieMaxage, String encodeString) { doSetCookie(request, response, cookieName, cookieValue, cookieMaxage, encodeString); } /** * 删除Cookie带cookie域名 */ public static void deleteCookie(HttpServletRequest request, HttpServletResponse response, String cookieName) { doSetCookie(request, response, cookieName, &quot;&quot;, -1, false); } /** * 设置Cookie的值，并使其在指定时间内生效 * * @param cookieMaxage cookie生效的最大秒数 */ private static final void doSetCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue, int cookieMaxage, boolean isEncode) { try { if (cookieValue == null) { cookieValue = &quot;&quot;; } else if (isEncode) { cookieValue = URLEncoder.encode(cookieValue, &quot;utf-8&quot;); } Cookie cookie = new Cookie(cookieName, cookieValue); if (cookieMaxage &gt; 0) cookie.setMaxAge(cookieMaxage); if (null != request) {// 设置域名的cookie String domainName = getDomainName(request); System.out.println(domainName); if (!&quot;localhost&quot;.equals(domainName)) { cookie.setDomain(domainName); } } cookie.setPath(&quot;/&quot;); response.addCookie(cookie); } catch (Exception e) { e.printStackTrace(); } } /** * 设置Cookie的值，并使其在指定时间内生效 * * @param cookieMaxage cookie生效的最大秒数 */ private static final void doSetCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue, int cookieMaxage, String encodeString) { try { if (cookieValue == null) { cookieValue = &quot;&quot;; } else { cookieValue = URLEncoder.encode(cookieValue, encodeString); } Cookie cookie = new Cookie(cookieName, cookieValue); if (cookieMaxage &gt; 0) cookie.setMaxAge(cookieMaxage); if (null != request) {// 设置域名的cookie String domainName = getDomainName(request); System.out.println(domainName); if (!&quot;localhost&quot;.equals(domainName)) { cookie.setDomain(domainName); } } cookie.setPath(&quot;/&quot;); response.addCookie(cookie); } catch (Exception e) { e.printStackTrace(); } } /** * 得到cookie的域名 */ private static final String getDomainName(HttpServletRequest request) { String domainName = null; String serverName = request.getRequestURL().toString(); if (serverName == null || serverName.equals(&quot;&quot;)) { domainName = &quot;&quot;; } else { serverName = serverName.toLowerCase(); serverName = serverName.substring(7); final int end = serverName.indexOf(&quot;/&quot;); serverName = serverName.substring(0, end); final String[] domains = serverName.split(&quot;\\\\.&quot;); int len = domains.length; if (len &gt; 3) { // www.xxx.com.cn domainName = &quot;.&quot; + domains[len - 3] + &quot;.&quot; + domains[len - 2] + &quot;.&quot; + domains[len - 1]; } else if (len &lt;= 3 &amp;&amp; len &gt; 1) { // xxx.com or xxx.cn domainName = &quot;.&quot; + domains[len - 2] + &quot;.&quot; + domains[len - 1]; } else { domainName = serverName; } } if (domainName != null &amp;&amp; domainName.indexOf(&quot;:&quot;) &gt; 0) { String[] ary = domainName.split(&quot;\\\\:&quot;); domainName = ary[0]; } return domainName; } } ExceptionUtil.javapackage com.taotao.common.utils; import java.io.PrintWriter; import java.io.StringWriter; public class ExceptionUtil { /** * 获取异常的堆栈信息 * * @param t * @return */ public static String getStackTrace(Throwable t) { StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); try { t.printStackTrace(pw); return sw.toString(); } finally { pw.close(); } } } FtpUtil.javapackage com.taotao.common.utils; import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import org.apache.commons.net.ftp.FTP; import org.apache.commons.net.ftp.FTPClient; import org.apache.commons.net.ftp.FTPFile; import org.apache.commons.net.ftp.FTPReply; /** * ftp上传下载工具类 * &lt;p&gt;Title: FtpUtil&lt;/p&gt; */ public class FtpUtil { /** * Description: 向FTP服务器上传文件 * @param host FTP服务器hostname * @param port FTP服务器端口 * @param username FTP登录账号 * @param password FTP登录密码 * @param basePath FTP服务器基础目录 * @param filePath FTP服务器文件存放路径。例如分日期存放：/2015/01/01。文件的路径为basePath+filePath * @param filename 上传到FTP服务器上的文件名 * @param input 输入流 * @return 成功返回true，否则返回false */ public static boolean uploadFile(String host, int port, String username, String password, String basePath, String filePath, String filename, InputStream input) { boolean result = false; FTPClient ftp = new FTPClient(); try { int reply; ftp.connect(host, port);// 连接FTP服务器 // 如果采用默认端口，可以使用ftp.connect(host)的方式直接连接FTP服务器 ftp.login(username, password);// 登录 reply = ftp.getReplyCode(); if (!FTPReply.isPositiveCompletion(reply)) { ftp.disconnect(); return result; } //切换到上传目录 if (!ftp.changeWorkingDirectory(basePath+filePath)) { //如果目录不存在创建目录 String[] dirs = filePath.split(&quot;/&quot;); String tempPath = basePath; for (String dir : dirs) { if (null == dir || &quot;&quot;.equals(dir)) continue; tempPath += &quot;/&quot; + dir; if (!ftp.changeWorkingDirectory(tempPath)) { if (!ftp.makeDirectory(tempPath)) { return result; } else { ftp.changeWorkingDirectory(tempPath); } } } } //设置上传文件的类型为二进制类型 ftp.setFileType(FTP.BINARY_FILE_TYPE); //上传文件 if (!ftp.storeFile(filename, input)) { return result; } input.close(); ftp.logout(); result = true; } catch (IOException e) { e.printStackTrace(); } finally { if (ftp.isConnected()) { try { ftp.disconnect(); } catch (IOException ioe) { } } } return result; } /** * Description: 从FTP服务器下载文件 * @param host FTP服务器hostname * @param port FTP服务器端口 * @param username FTP登录账号 * @param password FTP登录密码 * @param remotePath FTP服务器上的相对路径 * @param fileName 要下载的文件名 * @param localPath 下载后保存到本地的路径 * @return */ public static boolean downloadFile(String host, int port, String username, String password, String remotePath, String fileName, String localPath) { boolean result = false; FTPClient ftp = new FTPClient(); try { int reply; ftp.connect(host, port); // 如果采用默认端口，可以使用ftp.connect(host)的方式直接连接FTP服务器 ftp.login(username, password);// 登录 reply = ftp.getReplyCode(); if (!FTPReply.isPositiveCompletion(reply)) { ftp.disconnect(); return result; } ftp.changeWorkingDirectory(remotePath);// 转移到FTP服务器目录 FTPFile[] fs = ftp.listFiles(); for (FTPFile ff : fs) { if (ff.getName().equals(fileName)) { File localFile = new File(localPath + &quot;/&quot; + ff.getName()); OutputStream is = new FileOutputStream(localFile); ftp.retrieveFile(ff.getName(), is); is.close(); } } ftp.logout(); result = true; } catch (IOException e) { e.printStackTrace(); } finally { if (ftp.isConnected()) { try { ftp.disconnect(); } catch (IOException ioe) { } } } return result; } public static void main(String[] args) { try { FileInputStream in=new FileInputStream(new File(&quot;D:\\\\temp\\\\image\\\\gaigeming.jpg&quot;)); boolean flag = uploadFile(&quot;192.168.25.133&quot;, 21, &quot;ftpuser&quot;, &quot;ftpuser&quot;, &quot;/home/ftpuser/www/images&quot;,&quot;/2015/01/21&quot;, &quot;gaigeming.jpg&quot;, in); System.out.println(flag); } catch (FileNotFoundException e) { e.printStackTrace(); } } } HttpClientUtil.javapackage com.taotao.common.utils; import java.io.IOException; import java.net.URI; import java.util.ArrayList; import java.util.List; import java.util.Map; import org.apache.http.NameValuePair; import org.apache.http.client.entity.UrlEncodedFormEntity; import org.apache.http.client.methods.CloseableHttpResponse; import org.apache.http.client.methods.HttpGet; import org.apache.http.client.methods.HttpPost; import org.apache.http.client.utils.URIBuilder; import org.apache.http.entity.ContentType; import org.apache.http.entity.StringEntity; import org.apache.http.impl.client.CloseableHttpClient; import org.apache.http.impl.client.HttpClients; import org.apache.http.message.BasicNameValuePair; import org.apache.http.util.EntityUtils; public class HttpClientUtil { public static String doGet(String url, Map&lt;String, String&gt; param) { // 创建Httpclient对象 CloseableHttpClient httpclient = HttpClients.createDefault(); String resultString = &quot;&quot;; CloseableHttpResponse response = null; try { // 创建uri URIBuilder builder = new URIBuilder(url); if (param != null) { for (String key : param.keySet()) { builder.addParameter(key, param.get(key)); } } URI uri = builder.build(); // 创建http GET请求 HttpGet httpGet = new HttpGet(uri); // 执行请求 response = httpclient.execute(httpGet); // 判断返回状态是否为200 if (response.getStatusLine().getStatusCode() == 200) { resultString = EntityUtils.toString(response.getEntity(), &quot;UTF-8&quot;); } } catch (Exception e) { e.printStackTrace(); } finally { try { if (response != null) { response.close(); } httpclient.close(); } catch (IOException e) { e.printStackTrace(); } } return resultString; } public static String doGet(String url) { return doGet(url, null); } public static String doPost(String url, Map&lt;String, String&gt; param) { // 创建Httpclient对象 CloseableHttpClient httpClient = HttpClients.createDefault(); CloseableHttpResponse response = null; String resultString = &quot;&quot;; try { // 创建Http Post请求 HttpPost httpPost = new HttpPost(url); // 创建参数列表 if (param != null) { List&lt;NameValuePair&gt; paramList = new ArrayList&lt;&gt;(); for (String key : param.keySet()) { paramList.add(new BasicNameValuePair(key, param.get(key))); } // 模拟表单 UrlEncodedFormEntity entity = new UrlEncodedFormEntity(paramList); httpPost.setEntity(entity); } // 执行http请求 response = httpClient.execute(httpPost); resultString = EntityUtils.toString(response.getEntity(), &quot;utf-8&quot;); } catch (Exception e) { e.printStackTrace(); } finally { try { response.close(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } return resultString; } public static String doPost(String url) { return doPost(url, null); } public static String doPostJson(String url, String json) { // 创建Httpclient对象 CloseableHttpClient httpClient = HttpClients.createDefault(); CloseableHttpResponse response = null; String resultString = &quot;&quot;; try { // 创建Http Post请求 HttpPost httpPost = new HttpPost(url); // 创建请求内容 StringEntity entity = new StringEntity(json, ContentType.APPLICATION_JSON); httpPost.setEntity(entity); // 执行http请求 response = httpClient.execute(httpPost); resultString = EntityUtils.toString(response.getEntity(), &quot;utf-8&quot;); } catch (Exception e) { e.printStackTrace(); } finally { try { response.close(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } return resultString; } } IDUtils.javapackage com.taotao.common.utils; import java.util.Random; /** * 各种id生成策略 * &lt;p&gt;Title: IDUtils&lt;/p&gt; */ public class IDUtils { /** * 图片名生成 */ public static String genImageName() { //取当前时间的长整形值包含毫秒 long millis = System.currentTimeMillis(); //long millis = System.nanoTime(); //加上三位随机数 Random random = new Random(); int end3 = random.nextInt(999); //如果不足三位前面补0 String str = millis + String.format(&quot;%03d&quot;, end3); return str; } /** * 商品id生成 */ public static long genItemId() { //取当前时间的长整形值包含毫秒 long millis = System.currentTimeMillis(); //long millis = System.nanoTime(); //加上两位随机数 Random random = new Random(); int end2 = random.nextInt(99); //如果不足两位前面补0 String str = millis + String.format(&quot;%02d&quot;, end2); long id = new Long(str); return id; } public static void main(String[] args) { for(int i=0;i&lt; 100;i++) System.out.println(genItemId()); } } JsonUtils.javapackage com.taotao.common.utils; import java.util.List; import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.JavaType; import com.fasterxml.jackson.databind.ObjectMapper; /** * 自定义响应结构 */ public class JsonUtils { // 定义jackson对象 private static final ObjectMapper MAPPER = new ObjectMapper(); /** * 将对象转换成json字符串。 * &lt;p&gt;Title: pojoToJson&lt;/p&gt; * &lt;p&gt;Description: &lt;/p&gt; * @param data * @return */ public static String objectToJson(Object data) { try { String string = MAPPER.writeValueAsString(data); return string; } catch (JsonProcessingException e) { e.printStackTrace(); } return null; } /** * 将json结果集转化为对象 * * @param jsonData json数据 * @param clazz 对象中的object类型 * @return */ public static &lt;T&gt; T jsonToPojo(String jsonData, Class&lt;T&gt; beanType) { try { T t = MAPPER.readValue(jsonData, beanType); return t; } catch (Exception e) { e.printStackTrace(); } return null; } /** * 将json数据转换成pojo对象list * &lt;p&gt;Title: jsonToList&lt;/p&gt; * &lt;p&gt;Description: &lt;/p&gt; * @param jsonData * @param beanType * @return */ public static &lt;T&gt;List&lt;T&gt; jsonToList(String jsonData, Class&lt;T&gt; beanType) { JavaType javaType = MAPPER.getTypeFactory().constructParametricType(List.class, beanType); try { List&lt;T&gt; list = MAPPER.readValue(jsonData, javaType); return list; } catch (Exception e) { e.printStackTrace(); } return null; } }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"资源","slug":"资源","permalink":"/tags/资源/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"web前后端数据传输json格式的优雅编写","slug":"json数据传输中pojo的包装方式","date":"2020-05-16T02:38:22.000Z","updated":"2020-05-17T01:44:20.387Z","comments":true,"path":"null/json数据传输中pojo的包装方式/","link":"","permalink":"/null/json数据传输中pojo的包装方式/","excerpt":"","text":"目标 示例的编程语言为 java。 json 数据格式的产生就像套娃一样，前几层保证的是内容，只有最后一层才决定你的数据结构。 以下面的三个例子作为实现方式。 充分利用 java 的继承特性来达到代码的简洁优雅书写。 json 数据格式简介 json 数据均以 key:value 形式进行存储，且用逗号来分隔。 json 数据的{}中均是一个对象。 json 数据中[]里面的数据可以存储一个列表，也就是可以存储多个对象。 例如以下几种 json 数据// 1.在web传输中基本的数据格式 { &quot;status&quot;:200, &quot;msg&quot;:&quot;ok&quot;, &quot;data&quot;:&quot;this is json data&quot; } // 2.传输带有对象的json数据 { &quot;status&quot;:200, &quot;msg&quot;:&quot;ok&quot;, &quot;data&quot;: { &quot;name&quot;:&quot;zhangsan&quot;, &quot;age&quot;:11, &quot;sex&quot;:&quot;man&quot; } } // 3.传输带有列表的json数据 { &quot;payment&quot;:5288, &quot;postFee&quot;:0, &quot;userId&quot;:&quot;3&quot;, &quot;buyerMessage&quot;:null, &quot;buyerNick&quot;:&quot;zhang123&quot;, &quot;orderItems&quot;:[ // 这是第一个列表的第一个对象 { &quot;itemId&quot;:&quot;9&quot;, &quot;num&quot;:1, &quot;title&quot;:&quot;苹果111111111111111111111&quot;, &quot;price&quot;:5288, &quot;totaFee&quot;:5200, &quot;picPath&quot;:&quot;asdasdsadsadasdasdasd&quot; }, // 这是第一个列表的第二个对象 { &quot;itemId&quot;:&quot;10&quot;, &quot;num&quot;:2, &quot;title&quot;:&quot;苹果22222&quot;, &quot;price&quot;:5300, &quot;totaFee&quot;:5200, &quot;picPath&quot;:&quot;https://adasdasdasd&quot; } ], // 这是列表外的第二个对象 &quot;orderShipping&quot;:{ &quot;receiverName&quot;:&quot;张三&quot;, &quot;receiverPhone&quot;:&quot;1321231&quot;, &quot;receiverMobile&quot;:&quot;150000000&quot;, &quot;receiverState&quot;:&quot;上海&quot;, &quot;receiverCity&quot;:&quot;上海&quot;, &quot;receiverDistrict&quot;:&quot;三生三世&quot;, &quot;receiverAddress&quot;:&quot;少时诵诗书所&quot;, &quot;receiverZip&quot;:&quot;20000&quot; } } 准备工作创建一个 map 用来格式化最外层的 json 数据 使用了 jackson 啦产生 json 数据（如果是 web 项目只需要使用注解即可实现） /** * 产生json数据的 * JsonMap */ public class JsonMap { public static Map&lt;String, Object&gt; createJsonMap(final int status, final String msg, final Object data) { final Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;(); ObjectMapper objectMapper = new ObjectMapper(); map.put(&quot;status&quot;, status); map.put(&quot;message&quot;, msg); map.put(&quot;data&quot;, data); try { String json = objectMapper.writeValueAsString(map); return json; } catch (JsonProcessingException e) { e.printStackTrace(); } return &quot;&quot;; } public static void main(final String[] args) { String json = createJsonMap(200, &quot;ok&quot;, &quot;yes&quot;); System.out.println(json); } } 输出效果为{ &quot;message&quot;: &quot;ok&quot;, &quot;status&quot;: 200, &quot;data&quot;: &quot;yes&quot; } 创建三个 pojo 类用来模拟传输的数据 三个 pojo 仅仅是最后一个属性不同Tea 的为 hobby，Stu 为 addr，fam 为 sex下面仅列举其中之一 /** * 一个名字叫做fam的pojo类 * @author Shown * */ public class Pojofam { private String name; private int age; private String sex; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } } 向 json 中添加 1 个对象public static void main(final String[] args) { // 创建一个pojo并且设置属性 Pojofam pojofam = new Pojofam(); pojofam.setName(&quot;zhangsan&quot;); pojofam.setAge(15); pojofam.setSex(&quot;man&quot;); String json = createJsonMap(200, &quot;ok&quot;, pojofam); System.out.println(json); } 输出结果为{ &quot;status&quot;: 200, &quot;message&quot;: &quot;ok&quot;, &quot;data&quot;: { &quot;name&quot;: &quot;zhangsan&quot;, &quot;age&quot;: 15, &quot;sex&quot;: &quot;man&quot; } } 如果要想在对象中添加属性，但是不能直接在文件中加入，可以使用继承的方式（建议不要在项目开发到一半的时候去改动已经使用过的公共 pojo 一类的文件）举例说明，在 pojofam 这个对象上在加入一个 date 属性的话 新建 pojo 类继承 pojofam 类 /** * 一个名字叫做famSon的fam类的子类 * @author Shown * */ public class PojofamSon extends Pojofam{ private String date; public String getDate() { return date; } public void setDate(String date) { this.date = date; } } 创建对象并赋值 /** * 一个名字叫做famSon的fam类的子类 * @author Shown * */ public class PojofamSon extends Pojofam{ private String date; public String getDate() { return date; } public void setDate(String date) { this.date = date; } } 运行结果 @Test public void pojoSonTest() { PojofamSon pojofamSon = new PojofamSon(); pojofamSon.setName(&quot;lisi&quot;); pojofamSon.setAge(22); pojofamSon.setSex(&quot;women&quot;); Date date = new Date(); String strDateFormat = &quot;yyyy-MM-dd HH:mm:ss&quot;; SimpleDateFormat sdf = new SimpleDateFormat(strDateFormat); pojofamSon.setDate(sdf.format(date)); String json = JsonMap.createJsonMap(200, &quot;ok&quot;, pojofamSon); System.out.println(json); } 下面进行 json 中的属性加入多对象的操作 理清数据结构的类型 创建出刚好合适的 pojo 如果发现需要的 pojo 没有相应的属性，需要再次添加，请参照如上方法 输出多个不同的对象 创建 pojo，使对象作为属性 /** * 一个名字叫做PojoObj的pojo类,里面包括了3个pojo对象 * * @author Shown * */ public class PojoObj { private PojoStu pojoStu; private PojoTea pojoTea; private Pojofam pojofam; public PojoStu getPojoStu() { return pojoStu; } public void setPojoStu(PojoStu pojoStu) { this.pojoStu = pojoStu; } public PojoTea getPojoTea() { return pojoTea; } public void setPojoTea(PojoTea pojoTea) { this.pojoTea = pojoTea; } public Pojofam getPojofam() { return pojofam; } public void setPojofam(Pojofam pojofam) { this.pojofam = pojofam; } } 运行测试@Test public void pojoObjTest() { // 创建三个对象实例 PojoStu pojoStu = new PojoStu(); pojoStu.setName(&quot;zhangsan&quot;); PojoTea pojoTea = new PojoTea(); pojoTea.setName(&quot;wangwu&quot;); Pojofam pojofam = new Pojofam(); pojofam.setName(&quot;lisi&quot;); // 创建集合类实例 PojoObj ppObj = new PojoObj(); ppObj.setPojoStu(pojoStu); ppObj.setPojoTea(pojoTea); ppObj.setPojofam(pojofam); String json = JsonMap.createJsonMap(200, &quot;ok&quot;, ppObj); System.out.println(json); } 输出结果{ &quot;status&quot;: 200, &quot;message&quot;: &quot;ok&quot;, &quot;data&quot;: { &quot;pojoStu&quot;: { &quot;name&quot;: &quot;zhangsan&quot;, &quot;age&quot;: 0, &quot;sex&quot;: null }, &quot;pojoTea&quot;: { &quot;name&quot;: &quot;wangwu&quot;, &quot;age&quot;: 0, &quot;sex&quot;: null }, &quot;pojofam&quot;: { &quot;name&quot;: &quot;lisi&quot;, &quot;age&quot;: 0, &quot;sex&quot;: null } } } 列表封装 pojo，实现 json 输出列表/** * 一个名字叫做PojoObjList的pojo类,里面包括了2个pojo对象和一个列表对象 * * @author Shown * */ public class PojoObjlist { private PojoStu pojoStu; private PojoTea pojoTea; private List&lt;Pojofam&gt; pojofam; public PojoStu getPojoStu() { return pojoStu; } public void setPojoStu(PojoStu pojoStu) { this.pojoStu = pojoStu; } public PojoTea getPojoTea() { return pojoTea; } public void setPojoTea(PojoTea pojoTea) { this.pojoTea = pojoTea; } public List&lt;Pojofam&gt; getPojofam() { return pojofam; } public void setPojofam(List&lt;Pojofam&gt; pojofam) { this.pojofam = pojofam; } } 运行测试@Test public void pojoObjListTest() { // 创建两个对象实例 PojoStu pojoStu = new PojoStu(); pojoStu.setName(&quot;zhangsan&quot;); PojoTea pojoTea = new PojoTea(); pojoTea.setName(&quot;wangwu&quot;); // 创建一个存放pojo列表 List&lt;Pojofam&gt; pojofams = new ArrayList&lt;Pojofam&gt;(); Pojofam pojofam = new Pojofam(); pojofam.setName(&quot;lisi&quot;); Pojofam pojofam2 = new Pojofam(); pojofam.setName(&quot;lisi2&quot;); pojofams.add(pojofam); pojofams.add(pojofam2); // 创建结构化pojo PojoObjlist poboObjlist = new PojoObjlist(); poboObjlist.setPojofam(pojofams); poboObjlist.setPojoStu(pojoStu); poboObjlist.setPojoTea(pojoTea); String json = JsonMap.createJsonMap(200, &quot;ok&quot;, poboObjlist); System.out.println(json); } 测试结果{ &quot;status&quot;: 200, &quot;message&quot;: &quot;ok&quot;, &quot;data&quot;: { &quot;pojoStu&quot;: { &quot;name&quot;: &quot;zhangsan&quot;, &quot;age&quot;: 0, &quot;sex&quot;: null }, &quot;pojoTea&quot;: { &quot;name&quot;: &quot;wangwu&quot;, &quot;age&quot;: 0, &quot;sex&quot;: null }, &quot;pojofam&quot;: [ { &quot;name&quot;: &quot;lisi2&quot;, &quot;age&quot;: 0, &quot;sex&quot;: null }, { &quot;name&quot;: null, &quot;age&quot;: 0, &quot;sex&quot;: null } ] } } 总结：以上方法均可交叉使用，最后看的只是套娃 pojo 的最后一层，决定了你的 json 数据结构和显示方式。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"淘淘商城web项目复盘及改进","slug":"淘淘商城web项目复盘及改进","date":"2020-05-15T06:21:14.000Z","updated":"2020-05-17T01:48:26.905Z","comments":true,"path":"taotao/淘淘商城web项目复盘及改进/","link":"","permalink":"/taotao/淘淘商城web项目复盘及改进/","excerpt":"","text":"基于spring+mybatis框架开发的淘淘商城项目技术选型 Spring、SpringMVC、Mybatis JSP、JSTL、jQuery、jQuery plugin、EasyUI、KindEditor（富文本编辑器）、CSS+DIV Redis（缓存服务器） Solr（搜索） httpclient（调用系统服务） Mysql Nginx（web服务器） 开发工具和环境 Eclipse 4.5.0(Mars)，自带maven插件，需要手工安装svn插件。 Maven 3.3.3（开发工具自带） Tomcat 7.0.53（Maven Tomcat Plugin） JDK 1.7 Mysql 5.6 Nginx 1.8.0 Redis 3.0.0 Win10 操作系统 SVN（版本管理） 使用maven统一管理服务 方便管理依赖 统一版本控制 后台管理系统工程结构：taotao-parent – 管理依赖jar包的版本，全局，公司级别 –taotao-common — 通用组件、工具类–taotao-manage – 后台系统 –com.taotao.manage.web–com.taotao.manage.service–com.taotao.manage.mapper–com.taotao.manage.pojo 系统待改进的bug 在spring4.2之后均可以使用注解来实现跨域 用户信息存在cookie中不利于统一管理，应该使用redis来进行存储。 没有更进一步的安全措施，无法防止ddos等攻击手段 系统实现的模块 后台管理界面，用来进行对门户网站的显示内容的查找。 门户模块专门用来展示商品以及调取其他模块的服务接口，实现功能。 使用restful来进行对数据库的交互。 使用solr进行查询服务。 使用单点登录模块实现用户登录。 使用订单模块来生成订单。 开发后的感觉 纠错和处理异常时，从函数内部入手，并且进行一纠到底的行为，直到找到最后一层的函数，再逐层向外修改。 发现错误时，不要立即去找错误，查百度，而是进行程序运行逻辑的梳理，找到最后的根源，再入手。 冷静的头脑可以使你自己的工作效率大大提升。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"冒险岛游戏设计实现和GUI工具","slug":"冒险岛游戏","date":"2020-05-13T12:26:52.000Z","updated":"2020-05-16T01:16:01.246Z","comments":true,"path":"game/冒险岛游戏/","link":"","permalink":"/game/冒险岛游戏/","excerpt":"","text":"冒险岛游戏简介游戏界面简介 冒险岛开始界面 冒险岛游戏主界面 技术选型 编程语言及技术： java GUI 框架：Frame 多线程控制 双缓冲 项目的目录结构 项目的目录结构 项目中所用到的技巧 根据java的集成特性由继承的方式来基于frame框架定制适合自身的框架 利用map来制作图片工具类，用来进行项目初始化时只加载需要的图片，提高效率。 使用枚举类型的数据来标识项目中实体的方向和行为 利用列表容器来装怪物和子弹 将图片转换为字节流的工具类 tips：画笔使用的时候需要先取出然后清洗再进行重新赋值颜色 public class GameUtil { /** * 根据图片路径进行转换且可以设置图片放大倍数 * @param imgpath 图片路径 * @param beishu 放大的倍数 */ public static Image getImage(String imgpath,double beishu) { InputStream imgInput = new GameUtil().getClass().getResourceAsStream(imgpath); Image image = null; try { BufferedImage imgBuffered = ImageIO.read(imgInput); int width = (int) (imgBuffered.getWidth()*beishu); int height = (int) (imgBuffered.getHeight()*beishu); image = imgBuffered.getScaledInstance(width, height, Image.SCALE_DEFAULT); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } return image; } /** * 根据图片路径进行转换 * @param imgpath 图片路径 */ public static Image getImage(String imgpath) { InputStream imgInput = new GameUtil().getClass().getResourceAsStream(imgpath); Image image = null; try { BufferedImage imgBuffered = ImageIO.read(imgInput); int width = imgBuffered.getWidth(); int height = imgBuffered.getHeight(); image = imgBuffered.getScaledInstance(width, height, Image.SCALE_DEFAULT); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } return image; } /** * 改变图片的一条边 * @param imgpath 图片路径 * @param bian 边的长度 * @param state (0|1)(不改变宽|不改变长) */ public static Image getImage(String imgpath,int bian,int state) { InputStream imgInput = new GameUtil().getClass().getResourceAsStream(imgpath); Image image = null; try { BufferedImage imgBuffered = ImageIO.read(imgInput); int width = imgBuffered.getWidth(); int height = imgBuffered.getHeight(); if(state==0) { height = (int) ((double) bian / width * height) ; width = bian; }else { width = (int) ((double) bian / height * width) ; height = bian; } image = imgBuffered.getScaledInstance(width, height, Image.SCALE_DEFAULT); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } return image; } } 自定义的frame框架及使用 /** * @ClassName FrameUtil * @Description: 窗口初始化工具类 * @Author Xu Feng * @Date 2020/3/17 * @Version V1.0 **/ public class FrameUtil extends Frame implements KeyListener, MouseListener, MouseMotionListener{ public void Init(){ //设置窗口的初始位置 this.setBounds(400,200,Constant.GAME_WIDTH,Constant.GAME_HEIGHT); //设置窗口的标题 this.setTitle(&quot;冒险岛&quot;); //设置窗口关闭的监听事件 this.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); //添加键盘监听映射 this.addKeyListener(this); //添加鼠标监听映射 this.addMouseListener(this); //设置可见性 this.setVisible(true); //设置聚焦 this.setFocusable(true); //启动线程 new MyThread().run(); } // 解决图片闪烁的问题，用双缓冲方法解决闪烁问题 Image backImg = null; // 重写update()方法，在窗口的里层添加一个虚拟的图片 @Override public void update(Graphics g) { if (backImg == null) { // 如果虚拟图片不存在，创建一个和窗口一样大小的图片 backImg = createImage(Constant.GAME_WIDTH, Constant.GAME_HEIGHT); } // 获取到虚拟图片的画笔 Graphics backg = backImg.getGraphics(); Color c = backg.getColor(); backg.setColor(Color.white); backg.fillRect(0, 0, Constant.GAME_WIDTH, Constant.GAME_HEIGHT); backg.setColor(c); // 调用虚拟图片的paint()方法，每50ms刷新一次 paint(backg); g.drawImage(backImg, 0, 0, null); } @Override public void keyTyped(KeyEvent e) { } @Override public void keyPressed(KeyEvent e) { } @Override public void keyReleased(KeyEvent e) { } @Override public void mouseClicked(MouseEvent e) { } @Override public void mousePressed(MouseEvent e) { } @Override public void mouseReleased(MouseEvent e) { } @Override public void mouseEntered(MouseEvent e) { } @Override public void mouseExited(MouseEvent e) { } @Override public void mouseDragged(MouseEvent e) { } @Override public void mouseMoved(MouseEvent e) { } //启动线程重画画布 class MyThread extends Thread { @Override public void run() { for (; ; ) { repaint(); try { Thread.sleep(50); } catch (InterruptedException e) { e.printStackTrace(); } } } } } 单独进行一个线程来加载音乐 需要的jl播放器jar包的下载 package com.feng.untils; import javazoom.jl.decoder.JavaLayerException; import javazoom.jl.player.Player; import java.io.BufferedInputStream; import java.io.File; /** * @ClassName MusicUtil * @Description: 加载声音 * @Author Xu Feng * @Date 2020/3/20 * @Version V1.0 **/ public class MusicUtil extends Thread { private Player player; private File music; private String musicPath; private boolean loop; public MusicUtil(String musicPath){ this.musicPath = musicPath; } public MusicUtil(String musicPath,boolean loop){ this.musicPath = musicPath; this.loop = loop; } @Override public void run() { super.run(); try { if (loop){ while (true){ play(); } }else { play(); } }catch (JavaLayerException e){ e.printStackTrace(); } } public void play() throws JavaLayerException { BufferedInputStream buff = new BufferedInputStream(MusicUtil.class.getClassLoader() .getResourceAsStream(musicPath)); player = new Player(buff); player.play(); } public static void main(String[] args) { MusicUtil musicUtil = new MusicUtil(&quot;music/Bruno Mars - Talking to the Moon (Acoustic Piano).mp3&quot;,true); musicUtil.start(); } } 英雄自由落体的跳跃算法 //英雄的跳算法 public static List&lt;Integer&gt; jump(int y){ double v0 = 30; double vt = 0; double g = 9.8; double t = 0.5; double d_h = 0; List&lt;Integer&gt; jumps = new ArrayList(); boolean jump_up = true; //竖直上抛运动 if (jump_up){ for (;;){ System.out.println(+y); vt = v0 - g * t; d_h = v0 * t; v0 = vt; y -= d_h; jumps.add(y); System.out.println(&quot;竖直上抛:&quot;+y); if (vt&lt;=0){ v0 = 0; vt = 0; jump_up = false; System.out.println(&quot;自由落体最终:&quot;+y); break; } } } //自由落体 if (!jump_up){ for (;;){ vt = v0 + g * t; d_h = v0 * t; v0 = vt; y += d_h; jumps.add(y); if (y&gt;=400){ y = 400; v0 = 30; vt = 0; jump_up = true; System.out.println(&quot;自由落体最终:&quot;+y); break; } } } if (jumps.get(jumps.size()-1)&gt;= y){ Collections.replaceAll(jumps,jumps.get(jumps.size()-1),y); } return jumps; } static class jumpThread extends Thread{ @Override public void run() { for (int dy : jump(400)){ System.out.println(dy); try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } } } } 该项目完整代码的传送门","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"/tags/技术/"},{"name":"java","slug":"java","permalink":"/tags/java/"},{"name":"游戏","slug":"游戏","permalink":"/tags/游戏/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"java基础进阶细节","slug":"java基础进阶细节","date":"2020-05-12T12:20:36.000Z","updated":"2020-05-13T12:20:41.422Z","comments":true,"path":"basic/java基础进阶细节/","link":"","permalink":"/basic/java基础进阶细节/","excerpt":"","text":"[第2题] JDK源码要想拿高工资，JDK源码不可不读。总结一下比较重要的源码： 1、List、Map、Set实现类的源代码 2、ReentrantLock、AQS的源代码 3 AtomicInteger的实现原理，主要能说清楚CAS机制并且AtomicInteger是如何利用CAS机制实现的 4 线程池的实现原理 5 Object类中的方法以及每个方法的作用 [第二部分] 类和对象[第二篇] 面向对象基础[第1题] 面向对象是什么？面向对象是一种思想，世间万物都可以看做一个对象，这里只讨论面向对象编程（OOP），Java是一个支持并发、基于类和面向对象的计算机编程语言，面向对象软件开发的优点： 代码开发模块化，更易维护和修改； 代码复用性强； 增强代码的可靠性和灵活性； 增加代码的可读性。 面向对象的四大基本特性： 抽象：提取现实世界中某事物的关键特性，为该事物构建模型的过程。对同一事物在不同的需求下，需要提取的特性可能不一样。得到的抽象模型中一般包含：属性（数据）和操作（行为）。这个抽象模型我们称之为类。对类进行实例化得到对象。 封装：封装可以使类具有独立性和隔离性；保证类的高内聚。只暴露给类外部或者子类必须的属性和操作。类封装的实现依赖类的修饰符（public、protected和private等） 继承：对现有类的一种复用机制。一个类如果继承现有的类，则这个类将拥有被继承类的所有非私有特性（属性和操作）。这里指的继承包含：类的继承和接口的实现。 多态：多态是在继承的基础上实现的。多态的三个要素：继承、重写和父类引用指向子类对象。父类引用指向不同的子类对象时，调用相同的方法，呈现出不同的行为；就是类多态特性。多态可以分成编译时多态和运行时多态。 抽象、封装、继承和多态是面向对象的基础。在面向对象四大基础特性之上，我们在做面向对象编程设计时还需要遵循有一些基本的设计原则。 面向对象的七大设计原则：SOLID原则（单一职责原则、开放关闭原则、里氏替换原则、接口隔离原则和依赖倒置原则） 迪米特法则 组合优于继承原则（合成复用原则）。 在遵循这些面向对象设计原则基础上，前辈们总结出一些解决不同问题场景的设计模式，以四人帮的gof23最为知名。 24种设计模式(gof23+1)：创建型模式： 1.简单工厂模式（不包含在gof23中） 2.工厂模式 3.抽象工厂模式 4.单例模式 5.原型模式 创建者模式 6.结构型模式： 7.组合模式 8.装饰者模式 9.外观模式 10.适配器模式 11.代理模式 12.享元模式 13.桥接模式 行为型模式： 14.观察者模式 15.策略模式 16.状态模式 17.中介模式 18.模板方法 19.命令模式 20.备忘录模式 21.访问者模式 22.解释器模式 23.迭代器模式 24.职责链模式 [第2题] 类加载的过程 参考：https://blog.csdn.net/javazejian/article/details/73413292#启动bootstrap类加载器 a) 遇到一个新的类时，首先会到方法区去找class文件，如果没有找到就会去硬盘中找class文件，找到后会返回，将class文件加载到方法区中，在类加载的时候，静态成员变量会被分配到方法区的静态区域，非静态成员变量分配到非静态区域，然后开始给静态成员变量初始化，赋默认值，赋完默认值后，会根据静态成员变量书写的位置赋显示值，然后执行静态代码。当所有的静态代码执行完，类加载才算完成。 加载：类加载过程的一个阶段：通过一个类的完全限定查找此类字节码文件，并利用字节码文件创建一个Class对象 验证：目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。 准备：为类变量(即static修饰的字段变量)分配内存并且设置该类变量的初始值即0(如static int i=5;这里只将i初始化为0，至于5的值将在初始化时赋值)，这里不包含用final修饰的static，因为final在编译的时候就会分配了，注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。 解析：主要将常量池中的符号引用替换为直接引用的过程。符号引用就是一组符号来描述目标，可以是任何字面量，而直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。有类或接口的解析，字段解析，类方法解析，接口方法解析(这里涉及到字节码变量的引用，如需更详细了解，可参考《深入Java虚拟机》)。 初始化：类加载最后阶段，若该类具有超类，则对其进行初始化，执行静态初始化器和静态初始化成员变量(如前面只初始化了默认值的static变量将会在这个阶段赋值，成员变量也将被初始化)。 这便是类加载的5个过程，而类加载器的任务是根据一个类的全限定名来读取此类的二进制字节流到JVM中，然后转换为一个与目标类对应的java.lang.Class对象实例，在虚拟机提供了3种类加载器，引导（Bootstrap）类加载器、扩展（Extension）类加载器、系统（System）类加载器（也称应用类加载器） [第3题] 类加载器有哪些我们进一步了解类加载器间的关系(并非指继承关系)，主要可以分为以下4点 启动类加载器，由C++实现，没有父类。 拓展类加载器(ExtClassLoader)，由Java语言实现，父类加载器为null 系统类加载器(AppClassLoader)，由Java语言实现，父类加载器为ExtClassLoader 自定义类加载器，父类加载器肯定为AppClassLoader。 启动类加载器主要加载的是JVM自身需要的类，这个类加载使用C++语言实现的，是虚拟机自身的一部分，它负责将 /lib路径下的核心类库或-Xbootclasspath参数指定的路径下的jar包加载到内存中，注意必由于虚拟机是按照文件名识别加载jar包的，如rt.jar，如果文件名不被虚拟机识别，即使把jar包丢到lib目录下也是没有作用的(出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类)。 扩展类加载器是指Sun公司(已被Oracle收购)实现的sun.misc.Launcher$ExtClassLoader类，由Java语言实现的，是Launcher的静态内部类，它负责加载/lib/ext目录下或者由系统变量-Djava.ext.dir指定位路径中的类库，开发者可以直接使用标准扩展类加载器。 也称应用程序加载器是指 Sun公司实现的sun.misc.Launcher$AppClassLoader。它负责加载系统类路径java -classpath或-D java.class.path 指定路径下的类库，也就是我们经常用到的classpath路径，开发者可以直接使用系统类加载器，一般情况下该类加载是程序中默认的类加载器，通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器。 在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，需要注意的是，Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象，而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式即把请求交由父类处理，它一种任务委派模式，下面我们进一步了解它。 public class ClassLoaderTest { public static void main(String[] args) throws ClassNotFoundException { FileClassLoader loader1 = new FileClassLoader(rootDir); System.out.println(“自定义类加载器的父加载器: “+loader1.getParent()); System.out.println(“系统默认的AppClassLoader: “+ClassLoader.getSystemClassLoader()); System.out.println(“AppClassLoader的父类加载器: “+ClassLoader.getSystemClassLoader().getParent()); System.out.println(“ExtClassLoader的父类加载器: “+ClassLoader.getSystemClassLoader().getParent().getParent()); /* 输出结果: 自定义类加载器的父加载器: sun.misc.Launcher$AppClassLoader@29453f44 系统默认的AppClassLoader: sun.misc.Launcher$AppClassLoader@29453f44 AppClassLoader的父类加载器: sun.misc.Launcher$ExtClassLoader@6f94fa3e ExtClassLoader的父类加载器: null / } [第4题] 双亲委派模式双亲委派模式要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器，请注意双亲委派模式中的父子关系并非通常所说的类继承关系，而是采用组合关系来复用父类加载器的相关代码，类加载器间的关系如下 双亲委派模式是在Java 1.2后引入的，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己想办法去完成，这不就是传说中的实力坑爹啊？那么采用这种模式有啥用呢? 双亲委派模式优势 采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。可能你会想，如果我们在classpath路径下自定义一个名为java.lang.SingleInterge类(该类是胡编的)呢？该类并不存在java.lang中，经过双亲委托模式，传递到启动类加载器中，由于父类加载器路径下并没有该类，所以不会加载，将反向委托给子类加载器加载，最终会通过系统类加载器加载该类。但是这样做是不允许，因为java.lang是核心API包，需要访问权限，强制加载将会报出如下异常 java.lang.SecurityException: Prohibited package name: java.lang 1 所以无论如何都无法加载成功的。 [第5题] 编写自己的类加载器场景： 那么编写自定义类加载器的意义何在呢？ 当class文件不在ClassPath路径下，默认系统类加载器无法找到该class文件，在这种情况下我们需要实现一个自定义的ClassLoader来加载特定路径下的class文件生成class对象。 当一个class文件是通过网络传输并且可能会进行相应的加密操作时，需要先对class文件进行相应的解密后再加载到JVM内存中，这种情况下也需要编写自定义的ClassLoader并实现相应的逻辑。 当需要实现热部署功能时(一个class文件通过不同的类加载器产生不同class对象从而实现热部署功能)，需要实现自定义ClassLoader的逻辑。 方法： 实现自定义类加载器需要继承ClassLoader或者URLClassLoader，继承ClassLoader则需要自己重写findClass()方法并编写加载逻辑，继承URLClassLoader则可以省去编写findClass()方法以及class文件加载转换成字节码流的代码。 [第6题] 对象的创建a) 遇到一个新类时，会进行类的加载，定位到class文件 b) 对所有静态成员变量初始化，静态代码块也会执行，而且只在类加载的时候执行一次 c) New 对象时，jvm会在堆中分配一个足够大的存储空间 d) 存储空间清空，为所有的变量赋默认值，所有的对象引用赋值为null e) 根据书写的位置给字段一些初始化操作 f) 调用构造器方法（没有继承） [第7题] jvm的优化a) 设置参数，设置jvm的最大内存数 b) 垃圾回收器的选择 [第8题] 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。 Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。 [第9题] JDK和JRE的区别是什么？Java运行时环境(JRE)是将要执行Java程序的Java虚拟机。它同时也包含了执行applet需要的浏览器插件。Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序。 JDK（Java Development Kit）即为Java开发工具包，包含编写Java程序所必须的编译、运行等开发工具以及JRE。开发工具如：用于编译java程序的javac命令、用于启动JVM运行java程序的java命令、用于生成文档的javadoc命令以及用于打包的jar命令等等。 JRE（Java Runtime Environment）即为Java运行环境，提供了运行Java应用程序所必须的软件环境，包含有Java虚拟机（JVM）和丰富的系统类库。系统类库即为java提前封装好的功能类，只需拿来直接使用即可，可以大大的提高开发效率。 JVM（Java Virtual Machines）即为Java虚拟机，提供了字节码文件（.class）的运行环境支持。 简单说，就是JDK包含JRE包含JVM。 [第10题] ”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。 Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。 ###[第11题] 是否可以在static环境中访问非static变量？ static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。 ###[第12题] Java支持的数据类型有哪些？什么是自动拆装箱？ Java语言支持的8中基本数据类型是： byte short int long float double boolean char 自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成double，等等。反之就是自动拆箱。 基本数据类型： 整数值型：byte,short,int,long, 字符型：char 浮点类型：float,double 布尔型：boolean 整数默认int型，小数默认是double型。Float和long类型的必须加后缀。 首先知道String是引用类型不是基本类型，引用类型声明的变量是指该变量在内存中实际存储的是一个引用地址，实体在堆中。引用类型包括类、接口、数组等。String类还是final修饰的。 而包装类就属于引用类型，自动装箱和拆箱就是基本类型和引用类型之间的转换，至于为什么要转换，因为基本类型转换为引用类型后，就可以new对象，从而调用包装类中封装好的方法进行基本类型之间的转换或者toString（当然用类名直接调用也可以，便于一眼看出该方法是静态的），还有就是如果集合中想存放基本类型，泛型的限定类型只能是对应的包装类型。 [第13题] Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？Java中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。 [第14题] Java中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。在程序员没有给类提供构造函数的情况下，Java编译器会为这个类创建一个默认的构造函数。 Java中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己唯一的参数列表。 Java不支持像C++中那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，Java不会创建默认的复制构造函数。 [第15题] Java支持多继承么？不支持，Java不支持多继承。每个类都只能继承一个类，但是可以实现多个接口。 [第16题] 接口和抽象类的区别是什么？Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于： 接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。 类可以实现很多个接口，但是只能继承一个抽象类 类如果要实现一个接口，它必须要实现接口声明的所有方法。但是，类可以不实现抽象类声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。 抽象类可以在不提供接口方法实现的情况下实现接口。 Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。 Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。 接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。 也可以参考JDK8中抽象类和接口的区别 [第17题] 10.什么是值传递和引用传递？对象被值传递，意味着传递了对象的一个副本。因此，就算是改变了对象副本，也不会影响源对象的值。 对象被引用传递，意味着传递的并不是实际的对象，而是对象的引用。因此，外部对引用对象所做的改变会反映到所有的对象上。 [第18题] 我们能在 Switch 中使用 String 吗？从 Java 7 开始，我们可以在 switch case 中使用字符串，但这仅仅是一个语法糖。内部实现在 switch 中使用字符串的 hash code。 [第19题] 20.Java 中的构造器链是什么？当你从一个构造器中调用另一个构造器，就是Java 中的构造器链。这种情况只在重载了类的构造器的时候才会出现。 [第20题] 64 位 JVM 中，int 的长度是多数？Java 中，int 类型变量的长度是一个固定值，与平台无关，都是 32 位。意思就是说，在 32 位 和 64 位 的Java 虚拟机中，int 类型的长度是相同的。 [第21题]? 32 位和 64 位的 JVM，int 类型变量的长度是多数？ 32 位和 64 位的 JVM 中，int 类型变量的长度是相同的，都是 32 位或者 4 个字节。 [第22题]? “a==b”和”a.equals(b)”有什么区别？如果 a 和 b 都是对象，则 a==b 是比较两个对象的引用，只有当 a 和 b 指向的是堆中的同一个对象才会返回 true，而 a.equals(b) 是进行逻辑比较，所以通常需要重写该方法来提供逻辑一致性的比较。例如，String 类重写 equals() 方法，所以可以用于两个不同对象，但是包含的字母相同的比较。 [第23题] a.hashCode() 有什么用？与 a.equals(b) 有什么关系？hashCode() 方法是相应对象整型的 hash 值。它常用于基于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap等等。它与 equals() 方法关系特别紧密。根据 Java 规范，两个使用 equal() 方法来判断相等的对象，必须具有相同的 hash code。 [第24题] final、finalize 和 finally 的不同之处？final 是一个修饰符，可以修饰变量、方法和类。如果 final 修饰变量，意味着该变量的值在初始化后不能被改变。finalize 方法是在对象被回收之前调用的方法，给对象自己最后一个复活的机会，但是什么时候调用 finalize 没有保证。finally 是一个关键字，与 try 和 catch 一起用于异常的处理。finally 块一定会被执行，无论在 try 块中是否有发生异常。 [第25题] Java 中的编译期常量是什么？使用它又什么风险？公共静态不可变（public static final ）变量也就是我们所说的编译期常量，这里的 public 可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的jar。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。 [第26题] 用最有效率的方法计算2乘以8？答： 2 &lt;&lt; 3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"阅读","slug":"阅读","permalink":"/tags/阅读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"人总是在变，但是影视和音乐不变，资源分享。","slug":"我的第一篇blog","date":"2020-05-12T03:45:38.000Z","updated":"2020-05-13T02:33:05.264Z","comments":true,"path":"life/我的第一篇blog/","link":"","permalink":"/life/我的第一篇blog/","excerpt":"","text":"这是第一篇blog第一次就有关于生活的分享吧，闲时就会看看电影和听听音乐，但是有很多同学就有很多苦恼没有合适的网站，因为网上的视频资源良莠不齐，正版的又是广告连篇，下面就直接分享一下我正在使用的插件和各种网站。 影视资源 喜欢看影视 这个就是有点怀旧的感觉。 喜欢看影视 91美剧网 这是我看到过最全的美剧网站(虽然我看的美剧不多)，但是瑞克和莫提全季都有的。 91美剧网 独播库 这个网站是国内各大视频平台的独播剧的集合，要是还为独播剧而纠结，不妨在这个网站找一找。说不定会有惊喜的。 独播库 低端影视 这个的界面有点像家庭影院的界面，我很喜欢 别看它叫低端其实它可不低调。说不定有时候会给你点惊喜呢。 低端影视 no视频 韩剧爱好者的福音 音综爱好者的福音 动漫爱好者的天堂 no视频 音乐插件 建议大家用openwrt固件集成网易云插件，简直是不要太好用。 我以后应该还会写一点关于openwrt的东西","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"阅读","slug":"阅读","permalink":"/tags/阅读/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]}]}