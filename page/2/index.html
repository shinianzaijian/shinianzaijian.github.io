<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Shown的部落阁</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="用简洁的语言形容繁杂的配置">
<meta name="keywords" content="blog, Shown的部落阁, 配置, 资源">
<meta property="og:type" content="website">
<meta property="og:title" content="Shown的部落阁">
<meta property="og:url" content="/page/2/index.html">
<meta property="og:site_name" content="Shown的部落阁">
<meta property="og:description" content="用简洁的语言形容繁杂的配置">
<meta property="og:locale" content="zh-cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Shown的部落阁">
<meta name="twitter:description" content="用简洁的语言形容繁杂的配置">
  
    <link rel="alternate" href="/atom.xml" title="Shown的部落阁" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Shown的部落阁</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value=""></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-web开发中用到的工具类" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/webtools/web开发中用到的工具类/" class="article-date">
  <time datetime="2020-05-17T06:56:58.000Z" itemprop="datePublished">2020-05-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
<div class="article-gallery">
  <div class="article-gallery-photos">
    
      <a class="article-gallery-img fancybox" href="https://cdn.jsdelivr.net/gh/shinianzaijian/cdn/myimages/webtools.jpg" rel="gallery_ckzh6gugy000fnk97eamhbh0s">
        <img src="https://cdn.jsdelivr.net/gh/shinianzaijian/cdn/myimages/webtools.jpg" itemprop="image">
      </a>
    
  </div>
</div>

    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/webtools/web开发中用到的工具类/">web开发中用到的工具类</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="CookieUtils-java"><a href="#CookieUtils-java" class="headerlink" title="CookieUtils.java"></a>CookieUtils.java</h2><pre><code class="java">package com.taotao.common.utils;

import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.net.URLEncoder;

import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * 
 * Cookie 工具类
 *
 */
public final class CookieUtils {

    /**
     * 得到Cookie的值, 不编码
     * 
     * @param request
     * @param cookieName
     * @return
     */
    public static String getCookieValue(HttpServletRequest request, String cookieName) {
        return getCookieValue(request, cookieName, false);
    }

    /**
     * 得到Cookie的值,
     * 
     * @param request
     * @param cookieName
     * @return
     */
    public static String getCookieValue(HttpServletRequest request, String cookieName, boolean isDecoder) {
        Cookie[] cookieList = request.getCookies();
        if (cookieList == null || cookieName == null) {
            return null;
        }
        String retValue = null;
        try {
            for (int i = 0; i &lt; cookieList.length; i++) {
                if (cookieList[i].getName().equals(cookieName)) {
                    if (isDecoder) {
                        retValue = URLDecoder.decode(cookieList[i].getValue(), &quot;UTF-8&quot;);
                    } else {
                        retValue = cookieList[i].getValue();
                    }
                    break;
                }
            }
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
        return retValue;
    }

    /**
     * 得到Cookie的值,
     * 
     * @param request
     * @param cookieName
     * @return
     */
    public static String getCookieValue(HttpServletRequest request, String cookieName, String encodeString) {
        Cookie[] cookieList = request.getCookies();
        if (cookieList == null || cookieName == null) {
            return null;
        }
        String retValue = null;
        try {
            for (int i = 0; i &lt; cookieList.length; i++) {
                if (cookieList[i].getName().equals(cookieName)) {
                    retValue = URLDecoder.decode(cookieList[i].getValue(), encodeString);
                    break;
                }
            }
        } catch (UnsupportedEncodingException e) {
             e.printStackTrace();
        }
        return retValue;
    }

    /**
     * 设置Cookie的值 不设置生效时间默认浏览器关闭即失效,也不编码
     */
    public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName,
            String cookieValue) {
        setCookie(request, response, cookieName, cookieValue, -1);
    }

    /**
     * 设置Cookie的值 在指定时间内生效,但不编码
     */
    public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName,
            String cookieValue, int cookieMaxage) {
        setCookie(request, response, cookieName, cookieValue, cookieMaxage, false);
    }

    /**
     * 设置Cookie的值 不设置生效时间,但编码
     */
    public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName,
            String cookieValue, boolean isEncode) {
        setCookie(request, response, cookieName, cookieValue, -1, isEncode);
    }

    /**
     * 设置Cookie的值 在指定时间内生效, 编码参数
     */
    public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName,
            String cookieValue, int cookieMaxage, boolean isEncode) {
        doSetCookie(request, response, cookieName, cookieValue, cookieMaxage, isEncode);
    }

    /**
     * 设置Cookie的值 在指定时间内生效, 编码参数(指定编码)
     */
    public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName,
            String cookieValue, int cookieMaxage, String encodeString) {
        doSetCookie(request, response, cookieName, cookieValue, cookieMaxage, encodeString);
    }

    /**
     * 删除Cookie带cookie域名
     */
    public static void deleteCookie(HttpServletRequest request, HttpServletResponse response,
            String cookieName) {
        doSetCookie(request, response, cookieName, &quot;&quot;, -1, false);
    }

    /**
     * 设置Cookie的值，并使其在指定时间内生效
     * 
     * @param cookieMaxage cookie生效的最大秒数
     */
    private static final void doSetCookie(HttpServletRequest request, HttpServletResponse response,
            String cookieName, String cookieValue, int cookieMaxage, boolean isEncode) {
        try {
            if (cookieValue == null) {
                cookieValue = &quot;&quot;;
            } else if (isEncode) {
                cookieValue = URLEncoder.encode(cookieValue, &quot;utf-8&quot;);
            }
            Cookie cookie = new Cookie(cookieName, cookieValue);
            if (cookieMaxage &gt; 0)
                cookie.setMaxAge(cookieMaxage);
            if (null != request) {// 设置域名的cookie
                String domainName = getDomainName(request);
                System.out.println(domainName);
                if (!&quot;localhost&quot;.equals(domainName)) {
                    cookie.setDomain(domainName);
                }
            }
            cookie.setPath(&quot;/&quot;);
            response.addCookie(cookie);
        } catch (Exception e) {
             e.printStackTrace();
        }
    }

    /**
     * 设置Cookie的值，并使其在指定时间内生效
     * 
     * @param cookieMaxage cookie生效的最大秒数
     */
    private static final void doSetCookie(HttpServletRequest request, HttpServletResponse response,
            String cookieName, String cookieValue, int cookieMaxage, String encodeString) {
        try {
            if (cookieValue == null) {
                cookieValue = &quot;&quot;;
            } else {
                cookieValue = URLEncoder.encode(cookieValue, encodeString);
            }
            Cookie cookie = new Cookie(cookieName, cookieValue);
            if (cookieMaxage &gt; 0)
                cookie.setMaxAge(cookieMaxage);
            if (null != request) {// 设置域名的cookie
                String domainName = getDomainName(request);
                System.out.println(domainName);
                if (!&quot;localhost&quot;.equals(domainName)) {
                    cookie.setDomain(domainName);
                }
            }
            cookie.setPath(&quot;/&quot;);
            response.addCookie(cookie);
        } catch (Exception e) {
             e.printStackTrace();
        }
    }

    /**
     * 得到cookie的域名
     */
    private static final String getDomainName(HttpServletRequest request) {
        String domainName = null;

        String serverName = request.getRequestURL().toString();
        if (serverName == null || serverName.equals(&quot;&quot;)) {
            domainName = &quot;&quot;;
        } else {
            serverName = serverName.toLowerCase();
            serverName = serverName.substring(7);
            final int end = serverName.indexOf(&quot;/&quot;);
            serverName = serverName.substring(0, end);
            final String[] domains = serverName.split(&quot;\\.&quot;);
            int len = domains.length;
            if (len &gt; 3) {
                // www.xxx.com.cn
                domainName = &quot;.&quot; + domains[len - 3] + &quot;.&quot; + domains[len - 2] + &quot;.&quot; + domains[len - 1];
            } else if (len &lt;= 3 &amp;&amp; len &gt; 1) {
                // xxx.com or xxx.cn
                domainName = &quot;.&quot; + domains[len - 2] + &quot;.&quot; + domains[len - 1];
            } else {
                domainName = serverName;
            }
        }

        if (domainName != null &amp;&amp; domainName.indexOf(&quot;:&quot;) &gt; 0) {
            String[] ary = domainName.split(&quot;\\:&quot;);
            domainName = ary[0];
        }
        return domainName;
    }

}

</code></pre>
<h2 id="ExceptionUtil-java"><a href="#ExceptionUtil-java" class="headerlink" title="ExceptionUtil.java"></a>ExceptionUtil.java</h2><pre><code class="java">package com.taotao.common.utils;

import java.io.PrintWriter;
import java.io.StringWriter;

public class ExceptionUtil {

    /**
     * 获取异常的堆栈信息
     * 
     * @param t
     * @return
     */
    public static String getStackTrace(Throwable t) {
        StringWriter sw = new StringWriter();
        PrintWriter pw = new PrintWriter(sw);

        try {
            t.printStackTrace(pw);
            return sw.toString();
        } finally {
            pw.close();
        }
    }
}

</code></pre>
<h2 id="FtpUtil-java"><a href="#FtpUtil-java" class="headerlink" title="FtpUtil.java"></a>FtpUtil.java</h2><pre><code class="java">package com.taotao.common.utils;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

import org.apache.commons.net.ftp.FTP;
import org.apache.commons.net.ftp.FTPClient;
import org.apache.commons.net.ftp.FTPFile;
import org.apache.commons.net.ftp.FTPReply;

/**
 * ftp上传下载工具类
 * &lt;p&gt;Title: FtpUtil&lt;/p&gt;
 */
public class FtpUtil {

    /** 
     * Description: 向FTP服务器上传文件 
     * @param host FTP服务器hostname 
     * @param port FTP服务器端口 
     * @param username FTP登录账号 
     * @param password FTP登录密码 
     * @param basePath FTP服务器基础目录
     * @param filePath FTP服务器文件存放路径。例如分日期存放：/2015/01/01。文件的路径为basePath+filePath
     * @param filename 上传到FTP服务器上的文件名 
     * @param input 输入流 
     * @return 成功返回true，否则返回false 
     */  
    public static boolean uploadFile(String host, int port, String username, String password, String basePath,
            String filePath, String filename, InputStream input) {
        boolean result = false;
        FTPClient ftp = new FTPClient();
        try {
            int reply;
            ftp.connect(host, port);// 连接FTP服务器
            // 如果采用默认端口，可以使用ftp.connect(host)的方式直接连接FTP服务器
            ftp.login(username, password);// 登录
            reply = ftp.getReplyCode();
            if (!FTPReply.isPositiveCompletion(reply)) {
                ftp.disconnect();
                return result;
            }
            //切换到上传目录
            if (!ftp.changeWorkingDirectory(basePath+filePath)) {
                //如果目录不存在创建目录
                String[] dirs = filePath.split(&quot;/&quot;);
                String tempPath = basePath;
                for (String dir : dirs) {
                    if (null == dir || &quot;&quot;.equals(dir)) continue;
                    tempPath += &quot;/&quot; + dir;
                    if (!ftp.changeWorkingDirectory(tempPath)) {
                        if (!ftp.makeDirectory(tempPath)) {
                            return result;
                        } else {
                            ftp.changeWorkingDirectory(tempPath);
                        }
                    }
                }
            }
            //设置上传文件的类型为二进制类型
            ftp.setFileType(FTP.BINARY_FILE_TYPE);
            //上传文件
            if (!ftp.storeFile(filename, input)) {
                return result;
            }
            input.close();
            ftp.logout();
            result = true;
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (ftp.isConnected()) {
                try {
                    ftp.disconnect();
                } catch (IOException ioe) {
                }
            }
        }
        return result;
    }

    /** 
     * Description: 从FTP服务器下载文件 
     * @param host FTP服务器hostname 
     * @param port FTP服务器端口 
     * @param username FTP登录账号 
     * @param password FTP登录密码 
     * @param remotePath FTP服务器上的相对路径 
     * @param fileName 要下载的文件名 
     * @param localPath 下载后保存到本地的路径 
     * @return 
     */  
    public static boolean downloadFile(String host, int port, String username, String password, String remotePath,
            String fileName, String localPath) {
        boolean result = false;
        FTPClient ftp = new FTPClient();
        try {
            int reply;
            ftp.connect(host, port);
            // 如果采用默认端口，可以使用ftp.connect(host)的方式直接连接FTP服务器
            ftp.login(username, password);// 登录
            reply = ftp.getReplyCode();
            if (!FTPReply.isPositiveCompletion(reply)) {
                ftp.disconnect();
                return result;
            }
            ftp.changeWorkingDirectory(remotePath);// 转移到FTP服务器目录
            FTPFile[] fs = ftp.listFiles();
            for (FTPFile ff : fs) {
                if (ff.getName().equals(fileName)) {
                    File localFile = new File(localPath + &quot;/&quot; + ff.getName());

                    OutputStream is = new FileOutputStream(localFile);
                    ftp.retrieveFile(ff.getName(), is);
                    is.close();
                }
            }

            ftp.logout();
            result = true;
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (ftp.isConnected()) {
                try {
                    ftp.disconnect();
                } catch (IOException ioe) {
                }
            }
        }
        return result;
    }

    public static void main(String[] args) {
        try {  
            FileInputStream in=new FileInputStream(new File(&quot;D:\\temp\\image\\gaigeming.jpg&quot;));  
            boolean flag = uploadFile(&quot;192.168.25.133&quot;, 21, &quot;ftpuser&quot;, &quot;ftpuser&quot;, &quot;/home/ftpuser/www/images&quot;,&quot;/2015/01/21&quot;, &quot;gaigeming.jpg&quot;, in);  
            System.out.println(flag);  
        } catch (FileNotFoundException e) {  
            e.printStackTrace();  
        }  
    }
}

</code></pre>
<h2 id="HttpClientUtil-java"><a href="#HttpClientUtil-java" class="headerlink" title="HttpClientUtil.java"></a>HttpClientUtil.java</h2><pre><code class="java">package com.taotao.common.utils;

import java.io.IOException;
import java.net.URI;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import org.apache.http.NameValuePair;
import org.apache.http.client.entity.UrlEncodedFormEntity;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.utils.URIBuilder;
import org.apache.http.entity.ContentType;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.message.BasicNameValuePair;
import org.apache.http.util.EntityUtils;

public class HttpClientUtil {

    public static String doGet(String url, Map&lt;String, String&gt; param) {

        // 创建Httpclient对象
        CloseableHttpClient httpclient = HttpClients.createDefault();

        String resultString = &quot;&quot;;
        CloseableHttpResponse response = null;
        try {
            // 创建uri
            URIBuilder builder = new URIBuilder(url);
            if (param != null) {
                for (String key : param.keySet()) {
                    builder.addParameter(key, param.get(key));
                }
            }
            URI uri = builder.build();

            // 创建http GET请求
            HttpGet httpGet = new HttpGet(uri);

            // 执行请求
            response = httpclient.execute(httpGet);
            // 判断返回状态是否为200
            if (response.getStatusLine().getStatusCode() == 200) {
                resultString = EntityUtils.toString(response.getEntity(), &quot;UTF-8&quot;);
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                if (response != null) {
                    response.close();
                }
                httpclient.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return resultString;
    }

    public static String doGet(String url) {
        return doGet(url, null);
    }

    public static String doPost(String url, Map&lt;String, String&gt; param) {
        // 创建Httpclient对象
        CloseableHttpClient httpClient = HttpClients.createDefault();
        CloseableHttpResponse response = null;
        String resultString = &quot;&quot;;
        try {
            // 创建Http Post请求
            HttpPost httpPost = new HttpPost(url);
            // 创建参数列表
            if (param != null) {
                List&lt;NameValuePair&gt; paramList = new ArrayList&lt;&gt;();
                for (String key : param.keySet()) {
                    paramList.add(new BasicNameValuePair(key, param.get(key)));
                }
                // 模拟表单
                UrlEncodedFormEntity entity = new UrlEncodedFormEntity(paramList);
                httpPost.setEntity(entity);
            }
            // 执行http请求
            response = httpClient.execute(httpPost);
            resultString = EntityUtils.toString(response.getEntity(), &quot;utf-8&quot;);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                response.close();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }

        return resultString;
    }

    public static String doPost(String url) {
        return doPost(url, null);
    }

    public static String doPostJson(String url, String json) {
        // 创建Httpclient对象
        CloseableHttpClient httpClient = HttpClients.createDefault();
        CloseableHttpResponse response = null;
        String resultString = &quot;&quot;;
        try {
            // 创建Http Post请求
            HttpPost httpPost = new HttpPost(url);
            // 创建请求内容
            StringEntity entity = new StringEntity(json, ContentType.APPLICATION_JSON);
            httpPost.setEntity(entity);
            // 执行http请求
            response = httpClient.execute(httpPost);
            resultString = EntityUtils.toString(response.getEntity(), &quot;utf-8&quot;);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                response.close();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }

        return resultString;
    }
}
</code></pre>
<h2 id="IDUtils-java"><a href="#IDUtils-java" class="headerlink" title="IDUtils.java"></a>IDUtils.java</h2><pre><code class="java">package com.taotao.common.utils;

import java.util.Random;

/**
 * 各种id生成策略
 * &lt;p&gt;Title: IDUtils&lt;/p&gt;
 */
public class IDUtils {

    /**
     * 图片名生成
     */
    public static String genImageName() {
        //取当前时间的长整形值包含毫秒
        long millis = System.currentTimeMillis();
        //long millis = System.nanoTime();
        //加上三位随机数
        Random random = new Random();
        int end3 = random.nextInt(999);
        //如果不足三位前面补0
        String str = millis + String.format(&quot;%03d&quot;, end3);

        return str;
    }

    /**
     * 商品id生成
     */
    public static long genItemId() {
        //取当前时间的长整形值包含毫秒
        long millis = System.currentTimeMillis();
        //long millis = System.nanoTime();
        //加上两位随机数
        Random random = new Random();
        int end2 = random.nextInt(99);
        //如果不足两位前面补0
        String str = millis + String.format(&quot;%02d&quot;, end2);
        long id = new Long(str);
        return id;
    }

    public static void main(String[] args) {
        for(int i=0;i&lt; 100;i++)
        System.out.println(genItemId());
    }
}

</code></pre>
<h2 id="JsonUtils-java"><a href="#JsonUtils-java" class="headerlink" title="JsonUtils.java"></a>JsonUtils.java</h2><pre><code class="java">package com.taotao.common.utils;

import java.util.List;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.ObjectMapper;

/**
 * 自定义响应结构
 */
public class JsonUtils {

    // 定义jackson对象
    private static final ObjectMapper MAPPER = new ObjectMapper();

    /**
     * 将对象转换成json字符串。
     * &lt;p&gt;Title: pojoToJson&lt;/p&gt;
     * &lt;p&gt;Description: &lt;/p&gt;
     * @param data
     * @return
     */
    public static String objectToJson(Object data) {
        try {
            String string = MAPPER.writeValueAsString(data);
            return string;
        } catch (JsonProcessingException e) {
            e.printStackTrace();
        }
        return null;
    }

    /**
     * 将json结果集转化为对象
     * 
     * @param jsonData json数据
     * @param clazz 对象中的object类型
     * @return
     */
    public static &lt;T&gt; T jsonToPojo(String jsonData, Class&lt;T&gt; beanType) {
        try {
            T t = MAPPER.readValue(jsonData, beanType);
            return t;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    /**
     * 将json数据转换成pojo对象list
     * &lt;p&gt;Title: jsonToList&lt;/p&gt;
     * &lt;p&gt;Description: &lt;/p&gt;
     * @param jsonData
     * @param beanType
     * @return
     */
    public static &lt;T&gt;List&lt;T&gt; jsonToList(String jsonData, Class&lt;T&gt; beanType) {
        JavaType javaType = MAPPER.getTypeFactory().constructParametricType(List.class, beanType);
        try {
            List&lt;T&gt; list = MAPPER.readValue(jsonData, javaType);
            return list;
        } catch (Exception e) {
            e.printStackTrace();
        }

        return null;
    }

}
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="/webtools/web开发中用到的工具类/" data-id="ckzh6gugy000fnk97eamhbh0s" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web/">web</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/资源/">资源</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-json数据传输中pojo的包装方式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/null/json数据传输中pojo的包装方式/" class="article-date">
  <time datetime="2020-05-16T02:38:22.000Z" itemprop="datePublished">2020-05-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
<div class="article-gallery">
  <div class="article-gallery-photos">
    
      <a class="article-gallery-img fancybox" href="https://cdn.jsdelivr.net/gh/shinianzaijian/cdn/myimages/coding.jpg" rel="gallery_ckzh6gugl0007nk97c7so9hu9">
        <img src="https://cdn.jsdelivr.net/gh/shinianzaijian/cdn/myimages/coding.jpg" itemprop="image">
      </a>
    
  </div>
</div>

    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/null/json数据传输中pojo的包装方式/">web前后端数据传输json格式的优雅编写</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>示例的编程语言为 java。</li>
<li>json 数据格式的产生就像套娃一样，前几层保证的是内容，只有最后一层才决定你的数据结构。</li>
<li>以下面的三个例子作为实现方式。</li>
<li>充分利用 java 的继承特性来达到代码的简洁优雅书写。</li>
</ul>
<h2 id="json-数据格式简介"><a href="#json-数据格式简介" class="headerlink" title="json 数据格式简介"></a>json 数据格式简介</h2><ol>
<li>json 数据均以 key:value 形式进行存储，且用逗号来分隔。</li>
<li>json 数据的{}中均是一个对象。</li>
<li>json 数据中[]里面的数据可以存储一个列表，也就是可以存储多个对象。</li>
</ol>
<h3 id="例如以下几种-json-数据"><a href="#例如以下几种-json-数据" class="headerlink" title="例如以下几种 json 数据"></a>例如以下几种 json 数据</h3><pre><code class="json">// 1.在web传输中基本的数据格式
{
    &quot;status&quot;:200,
    &quot;msg&quot;:&quot;ok&quot;,
    &quot;data&quot;:&quot;this is json data&quot;
}

// 2.传输带有对象的json数据
{
    &quot;status&quot;:200,
    &quot;msg&quot;:&quot;ok&quot;,
    &quot;data&quot;: {
        &quot;name&quot;:&quot;zhangsan&quot;,
        &quot;age&quot;:11,
        &quot;sex&quot;:&quot;man&quot;
    }
}

// 3.传输带有列表的json数据
{
    &quot;payment&quot;:5288,
    &quot;postFee&quot;:0,
    &quot;userId&quot;:&quot;3&quot;,
    &quot;buyerMessage&quot;:null,
    &quot;buyerNick&quot;:&quot;zhang123&quot;,
    &quot;orderItems&quot;:[
        // 这是第一个列表的第一个对象
        {
            &quot;itemId&quot;:&quot;9&quot;,
            &quot;num&quot;:1,
            &quot;title&quot;:&quot;苹果111111111111111111111&quot;,
            &quot;price&quot;:5288,
            &quot;totaFee&quot;:5200,
            &quot;picPath&quot;:&quot;asdasdsadsadasdasdasd&quot;
        },
        // 这是第一个列表的第二个对象
        {
            &quot;itemId&quot;:&quot;10&quot;,
            &quot;num&quot;:2,
            &quot;title&quot;:&quot;苹果22222&quot;,
            &quot;price&quot;:5300,
            &quot;totaFee&quot;:5200,
            &quot;picPath&quot;:&quot;https://adasdasdasd&quot;
        }
    ],
    // 这是列表外的第二个对象
    &quot;orderShipping&quot;:{
        &quot;receiverName&quot;:&quot;张三&quot;,
        &quot;receiverPhone&quot;:&quot;1321231&quot;,
        &quot;receiverMobile&quot;:&quot;150000000&quot;,
        &quot;receiverState&quot;:&quot;上海&quot;,
        &quot;receiverCity&quot;:&quot;上海&quot;,
        &quot;receiverDistrict&quot;:&quot;三生三世&quot;,
        &quot;receiverAddress&quot;:&quot;少时诵诗书所&quot;,
        &quot;receiverZip&quot;:&quot;20000&quot;
    }
}


</code></pre>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="创建一个-map-用来格式化最外层的-json-数据"><a href="#创建一个-map-用来格式化最外层的-json-数据" class="headerlink" title="创建一个 map 用来格式化最外层的 json 数据"></a>创建一个 map 用来格式化最外层的 json 数据</h3><blockquote>
<p>使用了 jackson 啦产生 json 数据（如果是 web 项目只需要使用注解即可实现）</p>
</blockquote>
<pre><code class="java">/**
 * 产生json数据的
 * JsonMap
 */
public class JsonMap {

 public static Map&lt;String, Object&gt; createJsonMap(final int status, final String msg, final Object data) {

        final Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();
        ObjectMapper objectMapper = new ObjectMapper();
        map.put(&quot;status&quot;, status);
        map.put(&quot;message&quot;, msg);
        map.put(&quot;data&quot;, data);
        try {
            String json = objectMapper.writeValueAsString(map);
            return json;
        } catch (JsonProcessingException e) {
            e.printStackTrace();
        }
        return &quot;&quot;;

    }

      public static void main(final String[] args) {
        String json = createJsonMap(200, &quot;ok&quot;, &quot;yes&quot;);
        System.out.println(json);
    }

}
</code></pre>
<h4 id="输出效果为"><a href="#输出效果为" class="headerlink" title="输出效果为"></a>输出效果为</h4><pre><code class="json">{
  &quot;message&quot;: &quot;ok&quot;,
  &quot;status&quot;: 200,
  &quot;data&quot;: &quot;yes&quot;
}
</code></pre>
<h3 id="创建三个-pojo-类用来模拟传输的数据"><a href="#创建三个-pojo-类用来模拟传输的数据" class="headerlink" title="创建三个 pojo 类用来模拟传输的数据"></a>创建三个 pojo 类用来模拟传输的数据</h3><blockquote>
<p>三个 pojo 仅仅是最后一个属性不同<br>Tea 的为 hobby，Stu 为 addr，fam 为 sex<br>下面仅列举其中之一</p>
</blockquote>
<pre><code class="java">/**
 * 一个名字叫做fam的pojo类
 * @author Shown
 *
 */
public class Pojofam {

    private String name;
    private int age;
    private String sex;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getSex() {
        return sex;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }

}

</code></pre>
<h2 id="向-json-中添加-1-个对象"><a href="#向-json-中添加-1-个对象" class="headerlink" title="向 json 中添加 1 个对象"></a>向 json 中添加 1 个对象</h2><pre><code class="java">public static void main(final String[] args) {
        // 创建一个pojo并且设置属性
        Pojofam pojofam = new Pojofam();
        pojofam.setName(&quot;zhangsan&quot;);
        pojofam.setAge(15);
        pojofam.setSex(&quot;man&quot;);

        String json = createJsonMap(200, &quot;ok&quot;, pojofam);
        System.out.println(json);
    }
</code></pre>
<h3 id="输出结果为"><a href="#输出结果为" class="headerlink" title="输出结果为"></a>输出结果为</h3><pre><code class="json">{
  &quot;status&quot;: 200,
  &quot;message&quot;: &quot;ok&quot;,
  &quot;data&quot;: {
    &quot;name&quot;: &quot;zhangsan&quot;,
    &quot;age&quot;: 15,
    &quot;sex&quot;: &quot;man&quot;
  }
}
</code></pre>
<h2 id="如果要想在对象中添加属性，但是不能直接在文件中加入，可以使用继承的方式（建议不要在项目开发到一半的时候去改动已经使用过的公共-pojo-一类的文件）"><a href="#如果要想在对象中添加属性，但是不能直接在文件中加入，可以使用继承的方式（建议不要在项目开发到一半的时候去改动已经使用过的公共-pojo-一类的文件）" class="headerlink" title="如果要想在对象中添加属性，但是不能直接在文件中加入，可以使用继承的方式（建议不要在项目开发到一半的时候去改动已经使用过的公共 pojo 一类的文件）"></a>如果要想在对象中添加属性，但是不能直接在文件中加入，可以使用继承的方式（建议不要在项目开发到一半的时候去改动已经使用过的公共 pojo 一类的文件）</h2><h3 id="举例说明，在-pojofam-这个对象上在加入一个-date-属性的话"><a href="#举例说明，在-pojofam-这个对象上在加入一个-date-属性的话" class="headerlink" title="举例说明，在 pojofam 这个对象上在加入一个 date 属性的话"></a>举例说明，在 pojofam 这个对象上在加入一个 date 属性的话</h3><ol>
<li>新建 pojo 类继承 pojofam 类</li>
</ol>
<pre><code class="java">/**
 * 一个名字叫做famSon的fam类的子类
 * @author Shown
 *
 */
public class PojofamSon extends Pojofam{

    private String date;

    public String getDate() {
        return date;
    }

    public void setDate(String date) {
        this.date = date;
    }

}
</code></pre>
<ol start="2">
<li>创建对象并赋值</li>
</ol>
<pre><code class="java">/**
 * 一个名字叫做famSon的fam类的子类
 * @author Shown
 *
 */
public class PojofamSon extends Pojofam{

    private String date;

    public String getDate() {
        return date;
    }

    public void setDate(String date) {
        this.date = date;
    }

}
</code></pre>
<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><pre><code class="java">    @Test
    public void pojoSonTest() {
        PojofamSon pojofamSon = new PojofamSon();
        pojofamSon.setName(&quot;lisi&quot;);
        pojofamSon.setAge(22);
        pojofamSon.setSex(&quot;women&quot;);
        Date date = new Date();
        String strDateFormat = &quot;yyyy-MM-dd HH:mm:ss&quot;;
        SimpleDateFormat sdf = new SimpleDateFormat(strDateFormat);
        pojofamSon.setDate(sdf.format(date));
        String json = JsonMap.createJsonMap(200, &quot;ok&quot;, pojofamSon);
        System.out.println(json);
    }
</code></pre>
<h2 id="下面进行-json-中的属性加入多对象的操作"><a href="#下面进行-json-中的属性加入多对象的操作" class="headerlink" title="下面进行 json 中的属性加入多对象的操作"></a>下面进行 json 中的属性加入多对象的操作</h2><ol>
<li>理清数据结构的类型</li>
<li>创建出刚好合适的 pojo</li>
<li>如果发现需要的 pojo 没有相应的属性，需要再次添加，请参照如上方法</li>
</ol>
<h3 id="输出多个不同的对象"><a href="#输出多个不同的对象" class="headerlink" title="输出多个不同的对象"></a>输出多个不同的对象</h3><ol>
<li>创建 pojo，使对象作为属性</li>
</ol>
<pre><code class="java">/**
 * 一个名字叫做PojoObj的pojo类,里面包括了3个pojo对象
 *
 * @author Shown
 *
 */
public class PojoObj {

    private PojoStu pojoStu;
    private PojoTea pojoTea;
    private Pojofam pojofam;

    public PojoStu getPojoStu() {
        return pojoStu;
    }

    public void setPojoStu(PojoStu pojoStu) {
        this.pojoStu = pojoStu;
    }

    public PojoTea getPojoTea() {
        return pojoTea;
    }

    public void setPojoTea(PojoTea pojoTea) {
        this.pojoTea = pojoTea;
    }

    public Pojofam getPojofam() {
        return pojofam;
    }

    public void setPojofam(Pojofam pojofam) {
        this.pojofam = pojofam;
    }

}
</code></pre>
<h3 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h3><pre><code class="java">@Test
    public void pojoObjTest() {
        // 创建三个对象实例
        PojoStu pojoStu = new PojoStu();
        pojoStu.setName(&quot;zhangsan&quot;);
        PojoTea pojoTea = new PojoTea();
        pojoTea.setName(&quot;wangwu&quot;);
        Pojofam pojofam = new Pojofam();
        pojofam.setName(&quot;lisi&quot;);
        // 创建集合类实例
        PojoObj ppObj = new PojoObj();
        ppObj.setPojoStu(pojoStu);
        ppObj.setPojoTea(pojoTea);
        ppObj.setPojofam(pojofam);
        String json = JsonMap.createJsonMap(200, &quot;ok&quot;, ppObj);
        System.out.println(json);

    }
</code></pre>
<h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><pre><code class="json">{
  &quot;status&quot;: 200,
  &quot;message&quot;: &quot;ok&quot;,
  &quot;data&quot;: {
    &quot;pojoStu&quot;: {
      &quot;name&quot;: &quot;zhangsan&quot;,
      &quot;age&quot;: 0,
      &quot;sex&quot;: null
    },
    &quot;pojoTea&quot;: {
      &quot;name&quot;: &quot;wangwu&quot;,
      &quot;age&quot;: 0,
      &quot;sex&quot;: null
    },
    &quot;pojofam&quot;: {
      &quot;name&quot;: &quot;lisi&quot;,
      &quot;age&quot;: 0,
      &quot;sex&quot;: null
    }
  }
}
</code></pre>
<h2 id="列表封装-pojo，实现-json-输出列表"><a href="#列表封装-pojo，实现-json-输出列表" class="headerlink" title="列表封装 pojo，实现 json 输出列表"></a>列表封装 pojo，实现 json 输出列表</h2><pre><code class="java">/**
 * 一个名字叫做PojoObjList的pojo类,里面包括了2个pojo对象和一个列表对象
 *
 * @author Shown
 *
 */
public class PojoObjlist {

    private PojoStu pojoStu;
    private PojoTea pojoTea;
    private List&lt;Pojofam&gt; pojofam;

    public PojoStu getPojoStu() {
        return pojoStu;
    }

    public void setPojoStu(PojoStu pojoStu) {
        this.pojoStu = pojoStu;
    }

    public PojoTea getPojoTea() {
        return pojoTea;
    }

    public void setPojoTea(PojoTea pojoTea) {
        this.pojoTea = pojoTea;
    }

    public List&lt;Pojofam&gt; getPojofam() {
        return pojofam;
    }

    public void setPojofam(List&lt;Pojofam&gt; pojofam) {
        this.pojofam = pojofam;
    }

}
</code></pre>
<h3 id="运行测试-1"><a href="#运行测试-1" class="headerlink" title="运行测试"></a>运行测试</h3><pre><code class="java">@Test
    public void pojoObjListTest() {
        // 创建两个对象实例
        PojoStu pojoStu = new PojoStu();
        pojoStu.setName(&quot;zhangsan&quot;);
        PojoTea pojoTea = new PojoTea();
        pojoTea.setName(&quot;wangwu&quot;);
        // 创建一个存放pojo列表
        List&lt;Pojofam&gt; pojofams = new ArrayList&lt;Pojofam&gt;();
        Pojofam pojofam = new Pojofam();
        pojofam.setName(&quot;lisi&quot;);
        Pojofam pojofam2 = new Pojofam();
        pojofam.setName(&quot;lisi2&quot;);
        pojofams.add(pojofam);
        pojofams.add(pojofam2);
        // 创建结构化pojo
        PojoObjlist poboObjlist = new PojoObjlist();
        poboObjlist.setPojofam(pojofams);
        poboObjlist.setPojoStu(pojoStu);
        poboObjlist.setPojoTea(pojoTea);
        String json = JsonMap.createJsonMap(200, &quot;ok&quot;, poboObjlist);
        System.out.println(json);

    }
</code></pre>
<h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><pre><code class="json">{
  &quot;status&quot;: 200,
  &quot;message&quot;: &quot;ok&quot;,
  &quot;data&quot;: {
    &quot;pojoStu&quot;: {
      &quot;name&quot;: &quot;zhangsan&quot;,
      &quot;age&quot;: 0,
      &quot;sex&quot;: null
    },
    &quot;pojoTea&quot;: {
      &quot;name&quot;: &quot;wangwu&quot;,
      &quot;age&quot;: 0,
      &quot;sex&quot;: null
    },
    &quot;pojofam&quot;: [
      {
        &quot;name&quot;: &quot;lisi2&quot;,
        &quot;age&quot;: 0,
        &quot;sex&quot;: null
      },
      {
        &quot;name&quot;: null,
        &quot;age&quot;: 0,
        &quot;sex&quot;: null
      }
    ]
  }
}
</code></pre>
<h2 id="总结：以上方法均可交叉使用，最后看的只是套娃-pojo-的最后一层，决定了你的-json-数据结构和显示方式。"><a href="#总结：以上方法均可交叉使用，最后看的只是套娃-pojo-的最后一层，决定了你的-json-数据结构和显示方式。" class="headerlink" title="总结：以上方法均可交叉使用，最后看的只是套娃 pojo 的最后一层，决定了你的 json 数据结构和显示方式。"></a>总结：以上方法均可交叉使用，最后看的只是套娃 pojo 的最后一层，决定了你的 json 数据结构和显示方式。</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="/null/json数据传输中pojo的包装方式/" data-id="ckzh6gugl0007nk97c7so9hu9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web/">web</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/悦读/">悦读</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-淘淘商城web项目复盘及改进" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/taotao/淘淘商城web项目复盘及改进/" class="article-date">
  <time datetime="2020-05-15T06:21:14.000Z" itemprop="datePublished">2020-05-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
<div class="article-gallery">
  <div class="article-gallery-photos">
    
      <a class="article-gallery-img fancybox" href="https://cdn.jsdelivr.net/gh/shinianzaijian/cdn/2020.5.12/shop.jpg" rel="gallery_ckzh6guhg000znk97kvclgvi9">
        <img src="https://cdn.jsdelivr.net/gh/shinianzaijian/cdn/2020.5.12/shop.jpg" itemprop="image">
      </a>
    
  </div>
</div>

    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/taotao/淘淘商城web项目复盘及改进/">淘淘商城web项目复盘及改进</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="基于spring-mybatis框架开发的淘淘商城项目"><a href="#基于spring-mybatis框架开发的淘淘商城项目" class="headerlink" title="基于spring+mybatis框架开发的淘淘商城项目"></a>基于spring+mybatis框架开发的淘淘商城项目</h2><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><ul>
<li>Spring、SpringMVC、Mybatis</li>
<li>JSP、JSTL、jQuery、jQuery plugin、EasyUI、KindEditor（富文本编辑器）、CSS+DIV</li>
<li>Redis（缓存服务器）</li>
<li>Solr（搜索）</li>
<li>httpclient（调用系统服务）</li>
<li>Mysql</li>
<li>Nginx（web服务器）</li>
</ul>
<h3 id="开发工具和环境"><a href="#开发工具和环境" class="headerlink" title="开发工具和环境"></a>开发工具和环境</h3><ul>
<li>Eclipse 4.5.0(Mars)，自带maven插件，需要手工安装svn插件。</li>
<li>Maven 3.3.3（开发工具自带）</li>
<li>Tomcat 7.0.53（Maven Tomcat Plugin）</li>
<li>JDK 1.7</li>
<li>Mysql 5.6</li>
<li>Nginx 1.8.0</li>
<li>Redis 3.0.0</li>
<li>Win10 操作系统</li>
<li>SVN（版本管理）</li>
</ul>
<h3 id="使用maven统一管理服务"><a href="#使用maven统一管理服务" class="headerlink" title="使用maven统一管理服务"></a>使用maven统一管理服务</h3><ul>
<li>方便管理依赖</li>
<li>统一版本控制</li>
</ul>
<h3 id="后台管理系统工程结构："><a href="#后台管理系统工程结构：" class="headerlink" title="后台管理系统工程结构："></a>后台管理系统工程结构：</h3><p>taotao-parent – 管理依赖jar包的版本，全局，公司级别</p>
<blockquote>
<p>–taotao-common  — 通用组件、工具类<br>–taotao-manage  – 后台系统</p>
<blockquote>
<p>–com.taotao.manage.web<br>–com.taotao.manage.service<br>–com.taotao.manage.mapper<br>–com.taotao.manage.pojo</p>
</blockquote>
</blockquote>
<h3 id="系统待改进的bug"><a href="#系统待改进的bug" class="headerlink" title="系统待改进的bug"></a>系统待改进的bug</h3><ol>
<li>在spring4.2之后均可以使用注解来实现跨域</li>
<li>用户信息存在cookie中不利于统一管理，应该使用redis来进行存储。</li>
<li>没有更进一步的安全措施，无法防止ddos等攻击手段</li>
</ol>
<h3 id="系统实现的模块"><a href="#系统实现的模块" class="headerlink" title="系统实现的模块"></a>系统实现的模块</h3><ul>
<li>后台管理界面，用来进行对门户网站的显示内容的查找。</li>
<li>门户模块专门用来展示商品以及调取其他模块的服务接口，实现功能。</li>
<li>使用restful来进行对数据库的交互。</li>
<li>使用solr进行查询服务。</li>
<li>使用单点登录模块实现用户登录。</li>
<li>使用订单模块来生成订单。</li>
</ul>
<h3 id="开发后的感觉"><a href="#开发后的感觉" class="headerlink" title="开发后的感觉"></a>开发后的感觉</h3><ol>
<li>纠错和处理异常时，从函数内部入手，并且进行一纠到底的行为，直到找到最后一层的函数，再逐层向外修改。</li>
<li>发现错误时，不要立即去找错误，查百度，而是进行程序运行逻辑的梳理，找到最后的根源，再入手。</li>
<li>冷静的头脑可以使你自己的工作效率大大提升。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="/taotao/淘淘商城web项目复盘及改进/" data-id="ckzh6guhg000znk97kvclgvi9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web/">web</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/悦读/">悦读</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-冒险岛游戏" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/game/冒险岛游戏/" class="article-date">
  <time datetime="2020-05-13T12:26:52.000Z" itemprop="datePublished">2020-05-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
<div class="article-gallery">
  <div class="article-gallery-photos">
    
      <a class="article-gallery-img fancybox" href="https://cdn.jsdelivr.net/gh/shinianzaijian/cdn/2020.5.12/mapstyle.png" rel="gallery_ckzh6guh0000hnk97ocrv3w6j">
        <img src="https://cdn.jsdelivr.net/gh/shinianzaijian/cdn/2020.5.12/mapstyle.png" itemprop="image">
      </a>
    
  </div>
</div>

    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/game/冒险岛游戏/">冒险岛游戏设计实现和GUI工具</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="冒险岛游戏简介"><a href="#冒险岛游戏简介" class="headerlink" title="冒险岛游戏简介"></a>冒险岛游戏简介</h2><h3 id="游戏界面简介"><a href="#游戏界面简介" class="headerlink" title="游戏界面简介"></a>游戏界面简介</h3><p><img data-action="zoom" src="https://cdn.jsdelivr.net/gh/shinianzaijian/cdn/2020.5.12/mxdz.jpg" alt="冒险岛游戏开始界面" title="冒险岛开始界面"><br><img data-action="zoom" src="https://cdn.jsdelivr.net/gh/shinianzaijian/cdn/2020.5.12/mxdi.jpg" alt="冒险岛游戏主界面" title="冒险岛游戏主界面"></p>
<h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><ul>
<li>编程语言及技术： java GUI</li>
<li>框架：Frame</li>
<li>多线程控制</li>
<li>双缓冲</li>
</ul>
<hr>
<h3 id="项目的目录结构"><a href="#项目的目录结构" class="headerlink" title="项目的目录结构"></a>项目的目录结构</h3><p><img data-action="zoom" src="https://cdn.jsdelivr.net/gh/shinianzaijian/cdn/2020.5.12/mxdjava.jpg" alt="项目的目录结构" title="项目的目录结构"></p>
<h3 id="项目中所用到的技巧"><a href="#项目中所用到的技巧" class="headerlink" title="项目中所用到的技巧"></a>项目中所用到的技巧</h3><ul>
<li>根据java的集成特性由继承的方式来基于frame框架定制适合自身的框架</li>
<li>利用map来制作图片工具类，用来进行项目初始化时只加载需要的图片，提高效率。</li>
<li>使用枚举类型的数据来标识项目中实体的方向和行为</li>
<li>利用列表容器来装怪物和子弹</li>
<li>将图片转换为字节流的工具类</li>
</ul>
<blockquote>
<p>tips：画笔使用的时候需要先取出然后清洗再进行重新赋值颜色</p>
</blockquote>
<pre><code class="java">public class GameUtil {

/**
* 根据图片路径进行转换且可以设置图片放大倍数
* @param imgpath 图片路径
* @param beishu 放大的倍数
*/
public static Image getImage(String imgpath,double beishu) {
    InputStream imgInput = new GameUtil().getClass().getResourceAsStream(imgpath);
    Image image = null;
    try {
        BufferedImage imgBuffered = ImageIO.read(imgInput);
        int width = (int) (imgBuffered.getWidth()*beishu);
        int height = (int) (imgBuffered.getHeight()*beishu);
        image = imgBuffered.getScaledInstance(width, height, Image.SCALE_DEFAULT);
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    return image;
}

/**
    * 根据图片路径进行转换
    * @param imgpath 图片路径
    */
public static Image getImage(String imgpath) {
    InputStream imgInput = new GameUtil().getClass().getResourceAsStream(imgpath);
    Image image = null;
    try {
        BufferedImage imgBuffered = ImageIO.read(imgInput);
        int width = imgBuffered.getWidth();
        int height = imgBuffered.getHeight();
        image = imgBuffered.getScaledInstance(width, height, Image.SCALE_DEFAULT);
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    return image;
}

/**
    * 改变图片的一条边
    * @param imgpath 图片路径
    * @param bian 边的长度
    * @param state (0|1)(不改变宽|不改变长)
    */
public static Image getImage(String imgpath,int bian,int state) {
    InputStream imgInput = new GameUtil().getClass().getResourceAsStream(imgpath);
    Image image = null;
    try {
        BufferedImage imgBuffered = ImageIO.read(imgInput);
        int width = imgBuffered.getWidth();
        int height = imgBuffered.getHeight();
        if(state==0) {
            height = (int) ((double) bian / width * height) ;
            width = bian;
        }else {
            width = (int) ((double) bian / height * width) ;
            height = bian;
        }
        image = imgBuffered.getScaledInstance(width, height, Image.SCALE_DEFAULT);
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    return image;
}
}

</code></pre>
<ul>
<li>自定义的frame框架及使用</li>
</ul>
<pre><code class="java">/**
 * @ClassName FrameUtil
 * @Description: 窗口初始化工具类
 * @Author Xu Feng
 * @Date 2020/3/17
 * @Version V1.0
 **/
public class FrameUtil extends Frame implements KeyListener, MouseListener, MouseMotionListener{

    public void Init(){
        //设置窗口的初始位置
        this.setBounds(400,200,Constant.GAME_WIDTH,Constant.GAME_HEIGHT);
        //设置窗口的标题
        this.setTitle(&quot;冒险岛&quot;);
        //设置窗口关闭的监听事件
        this.addWindowListener(new WindowAdapter() {
            @Override
            public void windowClosing(WindowEvent e) {
                System.exit(0);
            }
        });
        //添加键盘监听映射
        this.addKeyListener(this);
        //添加鼠标监听映射
        this.addMouseListener(this);


        //设置可见性
        this.setVisible(true);
        //设置聚焦
        this.setFocusable(true);
        //启动线程
        new MyThread().run();
    }

    // 解决图片闪烁的问题，用双缓冲方法解决闪烁问题
    Image backImg = null;

    // 重写update()方法，在窗口的里层添加一个虚拟的图片
    @Override
    public void update(Graphics g) {
        if (backImg == null) {
            // 如果虚拟图片不存在，创建一个和窗口一样大小的图片
            backImg = createImage(Constant.GAME_WIDTH, Constant.GAME_HEIGHT);
        }
        // 获取到虚拟图片的画笔
        Graphics backg = backImg.getGraphics();
        Color c = backg.getColor();
        backg.setColor(Color.white);
        backg.fillRect(0, 0, Constant.GAME_WIDTH, Constant.GAME_HEIGHT);
        backg.setColor(c);
        // 调用虚拟图片的paint()方法，每50ms刷新一次
        paint(backg);
        g.drawImage(backImg, 0, 0, null);
    }

    @Override
    public void keyTyped(KeyEvent e) {

    }

    @Override
    public void keyPressed(KeyEvent e) {

    }

    @Override
    public void keyReleased(KeyEvent e) {

    }

    @Override
    public void mouseClicked(MouseEvent e) {

    }

    @Override
    public void mousePressed(MouseEvent e) {

    }

    @Override
    public void mouseReleased(MouseEvent e) {

    }

    @Override
    public void mouseEntered(MouseEvent e) {

    }

    @Override
    public void mouseExited(MouseEvent e) {

    }

    @Override
    public void mouseDragged(MouseEvent e) {

    }

    @Override
    public void mouseMoved(MouseEvent e) {

    }


    //启动线程重画画布
    class MyThread extends Thread {

        @Override
        public void run() {
            for (; ; ) {
                repaint();
                try {
                    Thread.sleep(50);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

}
</code></pre>
<ul>
<li>单独进行一个线程来加载音乐</li>
</ul>
<blockquote>
<p><a href="http://www.javazoom.net/javalayer/sources.html" target="_blank" rel="noopener">需要的jl播放器jar包的下载</a></p>
</blockquote>
<pre><code class="java">package com.feng.untils;

import javazoom.jl.decoder.JavaLayerException;
import javazoom.jl.player.Player;

import java.io.BufferedInputStream;
import java.io.File;

/**
 * @ClassName MusicUtil
 * @Description: 加载声音
 * @Author Xu Feng
 * @Date 2020/3/20
 * @Version V1.0
 **/
public class MusicUtil extends Thread {

    private Player player;
    private File music;

    private String musicPath;
    private boolean loop;

    public MusicUtil(String musicPath){
        this.musicPath = musicPath;
    }

    public MusicUtil(String musicPath,boolean loop){
        this.musicPath = musicPath;
        this.loop = loop;
    }

    @Override
    public void run() {
        super.run();
        try {
            if (loop){
                while (true){
                    play();
                }
            }else {
                play();
            }
        }catch (JavaLayerException e){
            e.printStackTrace();
        }
    }

    public void play() throws JavaLayerException {
        BufferedInputStream buff = new BufferedInputStream(MusicUtil.class.getClassLoader()
                .getResourceAsStream(musicPath));
        player = new Player(buff);
        player.play();
    }

    public static void main(String[] args) {
        MusicUtil musicUtil = new MusicUtil(&quot;music/Bruno Mars - Talking to the Moon (Acoustic Piano).mp3&quot;,true);
        musicUtil.start();
    }

}

</code></pre>
<ul>
<li>英雄自由落体的跳跃算法</li>
</ul>
<pre><code class="java">    //英雄的跳算法

    public static List&lt;Integer&gt; jump(int y){
        double v0 = 30;
        double vt = 0;
        double g = 9.8;
        double t = 0.5;
        double d_h = 0;

        List&lt;Integer&gt; jumps = new ArrayList();

        boolean jump_up = true;


        //竖直上抛运动
        if (jump_up){
            for (;;){
                System.out.println(+y);
                vt = v0 - g * t;
                d_h = v0 * t;
                v0 = vt;
                y -= d_h;
                jumps.add(y);
                System.out.println(&quot;竖直上抛:&quot;+y);
                if (vt&lt;=0){
                    v0 = 0;
                    vt = 0;
                    jump_up = false;
                    System.out.println(&quot;自由落体最终:&quot;+y);
                    break;
                }
            }
        }
        //自由落体
        if (!jump_up){
            for (;;){
                vt = v0 + g * t;
                d_h = v0 * t;
                v0 = vt;
                y += d_h;
                jumps.add(y);
                if (y&gt;=400){
                    y = 400;
                    v0 = 30;
                    vt = 0;
                    jump_up = true;
                    System.out.println(&quot;自由落体最终:&quot;+y);
                    break;
                }
            }
        }
        if (jumps.get(jumps.size()-1)&gt;= y){
            Collections.replaceAll(jumps,jumps.get(jumps.size()-1),y);
        }
      return jumps;
    }

    static class jumpThread extends Thread{

        @Override
        public void run() {
            for (int dy : jump(400)){
                System.out.println(dy);
                try {
                    Thread.sleep(5000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

</code></pre>
<h3 id="该项目完整代码的传送门"><a href="#该项目完整代码的传送门" class="headerlink" title="该项目完整代码的传送门"></a>该项目完整代码的<a href="https://github.com/shinianzaijian/Adventure-Island" target="_blank" rel="noopener">传送门</a></h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="/game/冒险岛游戏/" data-id="ckzh6guh0000hnk97ocrv3w6j" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/游戏/">游戏</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java基础进阶细节" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/basic/java基础进阶细节/" class="article-date">
  <time datetime="2020-05-12T12:20:36.000Z" itemprop="datePublished">2020-05-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
<div class="article-gallery">
  <div class="article-gallery-photos">
    
      <a class="article-gallery-img fancybox" href="https://cdn.jsdelivr.net/gh/shinianzaijian/cdn/2020.5.12/javajc.jpg" rel="gallery_ckzh6gugf0003nk97osgo9to3">
        <img src="https://cdn.jsdelivr.net/gh/shinianzaijian/cdn/2020.5.12/javajc.jpg" itemprop="image">
      </a>
    
  </div>
</div>

    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/basic/java基础进阶细节/">java基础进阶细节</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="第2题-JDK源码"><a href="#第2题-JDK源码" class="headerlink" title="[第2题] JDK源码"></a>[第2题] JDK源码</h3><p>要想拿高工资，JDK源码不可不读。总结一下比较重要的源码：</p>
<p>1、List、Map、Set实现类的源代码</p>
<p>2、ReentrantLock、AQS的源代码</p>
<p>3 AtomicInteger的实现原理，主要能说清楚CAS机制并且AtomicInteger是如何利用CAS机制实现的</p>
<p>4 线程池的实现原理</p>
<p>5 Object类中的方法以及每个方法的作用</p>
<h1 id="第二部分-类和对象"><a href="#第二部分-类和对象" class="headerlink" title="[第二部分] 类和对象"></a>[第二部分] 类和对象</h1><h2 id="第二篇-面向对象基础"><a href="#第二篇-面向对象基础" class="headerlink" title="[第二篇] 面向对象基础"></a>[第二篇] 面向对象基础</h2><h3 id="第1题-面向对象是什么？"><a href="#第1题-面向对象是什么？" class="headerlink" title="[第1题] 面向对象是什么？"></a>[第1题] 面向对象是什么？</h3><p>面向对象是一种思想，世间万物都可以看做一个对象，这里只讨论面向对象编程（OOP），Java是一个支持并发、基于类和面向对象的计算机编程语言，面向对象软件开发的优点：</p>
<p>代码开发模块化，更易维护和修改；</p>
<p>代码复用性强；</p>
<p>增强代码的可靠性和灵活性；</p>
<p>增加代码的可读性。</p>
<p>面向对象的四大基本特性：</p>
<p>抽象：提取现实世界中某事物的关键特性，为该事物构建模型的过程。对同一事物在不同的需求下，需要提取的特性可能不一样。得到的抽象模型中一般包含：属性（数据）和操作（行为）。这个抽象模型我们称之为类。对类进行实例化得到对象。</p>
<p>封装：封装可以使类具有独立性和隔离性；保证类的高内聚。只暴露给类外部或者子类必须的属性和操作。类封装的实现依赖类的修饰符（public、protected和private等）</p>
<p>继承：对现有类的一种复用机制。一个类如果继承现有的类，则这个类将拥有被继承类的所有非私有特性（属性和操作）。这里指的继承包含：类的继承和接口的实现。</p>
<p>多态：多态是在继承的基础上实现的。多态的三个要素：继承、重写和父类引用指向子类对象。父类引用指向不同的子类对象时，调用相同的方法，呈现出不同的行为；就是类多态特性。多态可以分成编译时多态和运行时多态。</p>
<p>抽象、封装、继承和多态是面向对象的基础。在面向对象四大基础特性之上，我们在做面向对象编程设计时还需要遵循有一些基本的设计原则。</p>
<hr>
<h3 id="面向对象的七大设计原则："><a href="#面向对象的七大设计原则：" class="headerlink" title="面向对象的七大设计原则："></a>面向对象的七大设计原则：</h3><p>SOLID原则（单一职责原则、开放关闭原则、里氏替换原则、接口隔离原则和依赖倒置原则）</p>
<p>迪米特法则</p>
<p>组合优于继承原则（合成复用原则）。</p>
<p>在遵循这些面向对象设计原则基础上，前辈们总结出一些解决不同问题场景的设计模式，以四人帮的gof23最为知名。</p>
<hr>
<h3 id="24种设计模式-gof23-1-："><a href="#24种设计模式-gof23-1-：" class="headerlink" title="24种设计模式(gof23+1)："></a>24种设计模式(gof23+1)：</h3><p>创建型模式：</p>
<p>1.简单工厂模式（不包含在gof23中）</p>
<p>2.工厂模式</p>
<p>3.抽象工厂模式</p>
<p>4.单例模式</p>
<p>5.原型模式</p>
<p>创建者模式</p>
<p>6.结构型模式：</p>
<p>7.组合模式</p>
<p>8.装饰者模式</p>
<p>9.外观模式</p>
<p>10.适配器模式</p>
<p>11.代理模式</p>
<p>12.享元模式</p>
<p>13.桥接模式</p>
<p>行为型模式：</p>
<p>14.观察者模式</p>
<p>15.策略模式</p>
<p>16.状态模式</p>
<p>17.中介模式</p>
<p>18.模板方法</p>
<p>19.命令模式</p>
<p>20.备忘录模式</p>
<p>21.访问者模式</p>
<p>22.解释器模式</p>
<p>23.迭代器模式</p>
<p>24.职责链模式</p>
<h3 id="第2题-类加载的过程"><a href="#第2题-类加载的过程" class="headerlink" title="[第2题] 类加载的过程"></a>[第2题] 类加载的过程</h3><blockquote>
<p>参考：<a href="https://blog.csdn.net/javazejian/article/details/73413292#启动bootstrap类加载器" target="_blank" rel="noopener">https://blog.csdn.net/javazejian/article/details/73413292#启动bootstrap类加载器</a></p>
</blockquote>
<p>a) 遇到一个新的类时，首先会到方法区去找class文件，如果没有找到就会去硬盘中找class文件，找到后会返回，将class文件加载到方法区中，在类加载的时候，静态成员变量会被分配到方法区的静态区域，非静态成员变量分配到非静态区域，然后开始给静态成员变量初始化，赋默认值，赋完默认值后，会根据静态成员变量书写的位置赋显示值，然后执行静态代码。当所有的静态代码执行完，类加载才算完成。</p>
<p>加载：类加载过程的一个阶段：通过一个类的完全限定查找此类字节码文件，并利用字节码文件创建一个Class对象</p>
<p>验证：目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</p>
<p>准备：为类变量(即static修饰的字段变量)分配内存并且设置该类变量的初始值即0(如static int i=5;这里只将i初始化为0，至于5的值将在初始化时赋值)，这里不包含用final修饰的static，因为final在编译的时候就会分配了，注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</p>
<p>解析：主要将常量池中的符号引用替换为直接引用的过程。符号引用就是一组符号来描述目标，可以是任何字面量，而直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。有类或接口的解析，字段解析，类方法解析，接口方法解析(这里涉及到字节码变量的引用，如需更详细了解，可参考《深入Java虚拟机》)。</p>
<p>初始化：类加载最后阶段，若该类具有超类，则对其进行初始化，执行静态初始化器和静态初始化成员变量(如前面只初始化了默认值的static变量将会在这个阶段赋值，成员变量也将被初始化)。</p>
<p>这便是类加载的5个过程，而类加载器的任务是根据一个类的全限定名来读取此类的二进制字节流到JVM中，然后转换为一个与目标类对应的java.lang.Class对象实例，在虚拟机提供了3种类加载器，引导（Bootstrap）类加载器、扩展（Extension）类加载器、系统（System）类加载器（也称应用类加载器）</p>
<h3 id="第3题-类加载器有哪些"><a href="#第3题-类加载器有哪些" class="headerlink" title="[第3题] 类加载器有哪些"></a>[第3题] 类加载器有哪些</h3><p>我们进一步了解类加载器间的关系(并非指继承关系)，主要可以分为以下4点</p>
<p>启动类加载器，由C++实现，没有父类。</p>
<p>拓展类加载器(ExtClassLoader)，由Java语言实现，父类加载器为null</p>
<p>系统类加载器(AppClassLoader)，由Java语言实现，父类加载器为ExtClassLoader</p>
<p>自定义类加载器，父类加载器肯定为AppClassLoader。</p>
<p>启动类加载器主要加载的是JVM自身需要的类，这个类加载使用C++语言实现的，是虚拟机自身的一部分，它负责将 /lib路径下的核心类库或-Xbootclasspath参数指定的路径下的jar包加载到内存中，注意必由于虚拟机是按照文件名识别加载jar包的，如rt.jar，如果文件名不被虚拟机识别，即使把jar包丢到lib目录下也是没有作用的(出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类)。</p>
<p>扩展类加载器是指Sun公司(已被Oracle收购)实现的sun.misc.Launcher$ExtClassLoader类，由Java语言实现的，是Launcher的静态内部类，它负责加载/lib/ext目录下或者由系统变量-Djava.ext.dir指定位路径中的类库，开发者可以直接使用标准扩展类加载器。</p>
<p>也称应用程序加载器是指 Sun公司实现的sun.misc.Launcher$AppClassLoader。它负责加载系统类路径java -classpath或-D java.class.path 指定路径下的类库，也就是我们经常用到的classpath路径，开发者可以直接使用系统类加载器，一般情况下该类加载是程序中默认的类加载器，通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器。</p>
<p>　 在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，需要注意的是，Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象，而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式即把请求交由父类处理，它一种任务委派模式，下面我们进一步了解它。</p>
<p>public class ClassLoaderTest { public static void main(String[] args) throws ClassNotFoundException { FileClassLoader loader1 = new FileClassLoader(rootDir); System.out.println(“自定义类加载器的父加载器: “+loader1.getParent()); System.out.println(“系统默认的AppClassLoader: “+ClassLoader.getSystemClassLoader()); System.out.println(“AppClassLoader的父类加载器: “+ClassLoader.getSystemClassLoader().getParent()); System.out.println(“ExtClassLoader的父类加载器: “+ClassLoader.getSystemClassLoader().getParent().getParent()); /*<em> 输出结果: 自定义类加载器的父加载器: sun.misc.Launcher$AppClassLoader@29453f44 系统默认的AppClassLoader: sun.misc.Launcher$AppClassLoader@29453f44 AppClassLoader的父类加载器: sun.misc.Launcher$ExtClassLoader@6f94fa3e ExtClassLoader的父类加载器: null </em>/ }</p>
<h3 id="第4题-双亲委派模式"><a href="#第4题-双亲委派模式" class="headerlink" title="[第4题] 双亲委派模式"></a>[第4题] 双亲委派模式</h3><p>双亲委派模式要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器，请注意双亲委派模式中的父子关系并非通常所说的类继承关系，而是采用组合关系来复用父类加载器的相关代码，类加载器间的关系如下</p>
<p>双亲委派模式是在Java 1.2后引入的，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己想办法去完成，这不就是传说中的实力坑爹啊？那么采用这种模式有啥用呢?</p>
<p>双亲委派模式优势</p>
<p>采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。可能你会想，如果我们在classpath路径下自定义一个名为java.lang.SingleInterge类(该类是胡编的)呢？该类并不存在java.lang中，经过双亲委托模式，传递到启动类加载器中，由于父类加载器路径下并没有该类，所以不会加载，将反向委托给子类加载器加载，最终会通过系统类加载器加载该类。但是这样做是不允许，因为java.lang是核心API包，需要访问权限，强制加载将会报出如下异常</p>
<p>java.lang.SecurityException: Prohibited package name: java.lang</p>
<p>1</p>
<p>所以无论如何都无法加载成功的。</p>
<h3 id="第5题-编写自己的类加载器"><a href="#第5题-编写自己的类加载器" class="headerlink" title="[第5题] 编写自己的类加载器"></a>[第5题] 编写自己的类加载器</h3><p>场景：</p>
<p>那么编写自定义类加载器的意义何在呢？</p>
<p>当class文件不在ClassPath路径下，默认系统类加载器无法找到该class文件，在这种情况下我们需要实现一个自定义的ClassLoader来加载特定路径下的class文件生成class对象。</p>
<p>当一个class文件是通过网络传输并且可能会进行相应的加密操作时，需要先对class文件进行相应的解密后再加载到JVM内存中，这种情况下也需要编写自定义的ClassLoader并实现相应的逻辑。</p>
<p>当需要实现热部署功能时(一个class文件通过不同的类加载器产生不同class对象从而实现热部署功能)，需要实现自定义ClassLoader的逻辑。</p>
<p>方法：</p>
<p>实现自定义类加载器需要继承ClassLoader或者URLClassLoader，继承ClassLoader则需要自己重写findClass()方法并编写加载逻辑，继承URLClassLoader则可以省去编写findClass()方法以及class文件加载转换成字节码流的代码。</p>
<h3 id="第6题-对象的创建"><a href="#第6题-对象的创建" class="headerlink" title="[第6题] 对象的创建"></a>[第6题] 对象的创建</h3><p>a) 遇到一个新类时，会进行类的加载，定位到class文件</p>
<p>b) 对所有静态成员变量初始化，静态代码块也会执行，而且只在类加载的时候执行一次</p>
<p>c) New 对象时，jvm会在堆中分配一个足够大的存储空间</p>
<p>d) 存储空间清空，为所有的变量赋默认值，所有的对象引用赋值为null</p>
<p>e) 根据书写的位置给字段一些初始化操作</p>
<p>f) 调用构造器方法（没有继承）</p>
<h3 id="第7题-jvm的优化"><a href="#第7题-jvm的优化" class="headerlink" title="[第7题] jvm的优化"></a>[第7题] jvm的优化</h3><p>a) 设置参数，设置jvm的最大内存数</p>
<p>b) 垃圾回收器的选择</p>
<h3 id="第8题-什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？"><a href="#第8题-什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？" class="headerlink" title="[第8题] 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？"></a>[第8题] 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？</h3><p>Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。</p>
<p>Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。</p>
<h3 id="第9题-JDK和JRE的区别是什么？"><a href="#第9题-JDK和JRE的区别是什么？" class="headerlink" title="[第9题] JDK和JRE的区别是什么？"></a>[第9题] JDK和JRE的区别是什么？</h3><p>Java运行时环境(JRE)是将要执行Java程序的Java虚拟机。它同时也包含了执行applet需要的浏览器插件。Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序。</p>
<p>JDK（Java Development Kit）即为Java开发工具包，包含编写Java程序所必须的编译、运行等开发工具以及JRE。开发工具如：用于编译java程序的javac命令、用于启动JVM运行java程序的java命令、用于生成文档的javadoc命令以及用于打包的jar命令等等。</p>
<p>JRE（Java Runtime Environment）即为Java运行环境，提供了运行Java应用程序所必须的软件环境，包含有Java虚拟机（JVM）和丰富的系统类库。系统类库即为java提前封装好的功能类，只需拿来直接使用即可，可以大大的提高开发效率。</p>
<p>JVM（Java Virtual Machines）即为Java虚拟机，提供了字节码文件（.class）的运行环境支持。</p>
<p>简单说，就是JDK包含JRE包含JVM。</p>
<h3 id="第10题-”static”关键字是什么意思？Java中是否可以覆盖-override-一个private或者是static的方法？"><a href="#第10题-”static”关键字是什么意思？Java中是否可以覆盖-override-一个private或者是static的方法？" class="headerlink" title="[第10题] ”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？"></a>[第10题] ”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？</h3><p>“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。</p>
<p>Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。</p>
<p>###[第11题] 是否可以在static环境中访问非static变量？</p>
<p>static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。</p>
<p>###[第12题] Java支持的数据类型有哪些？什么是自动拆装箱？</p>
<p>Java语言支持的8中基本数据类型是：</p>
<p>byte</p>
<p>short</p>
<p>int</p>
<p>long</p>
<p>float</p>
<p>double</p>
<p>boolean</p>
<p>char</p>
<p>自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成double，等等。反之就是自动拆箱。</p>
<p>基本数据类型：</p>
<p>整数值型：byte,short,int,long,</p>
<p>字符型：char</p>
<p>浮点类型：float,double</p>
<p>布尔型：boolean</p>
<p>整数默认int型，小数默认是double型。Float和long类型的必须加后缀。</p>
<p>首先知道String是引用类型不是基本类型，引用类型声明的变量是指该变量在内存中实际存储的是一个引用地址，实体在堆中。引用类型包括类、接口、数组等。String类还是final修饰的。</p>
<p>而包装类就属于引用类型，自动装箱和拆箱就是基本类型和引用类型之间的转换，至于为什么要转换，因为基本类型转换为引用类型后，就可以new对象，从而调用包装类中封装好的方法进行基本类型之间的转换或者toString（当然用类名直接调用也可以，便于一眼看出该方法是静态的），还有就是如果集合中想存放基本类型，泛型的限定类型只能是对应的包装类型。</p>
<h3 id="第13题-Java中的方法覆盖-Overriding-和方法重载-Overloading-是什么意思？"><a href="#第13题-Java中的方法覆盖-Overriding-和方法重载-Overloading-是什么意思？" class="headerlink" title="[第13题] Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？"></a>[第13题] Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？</h3><p>Java中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。</p>
<h3 id="第14题-Java中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？"><a href="#第14题-Java中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？" class="headerlink" title="[第14题] Java中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？"></a>[第14题] Java中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？</h3><p>当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。在程序员没有给类提供构造函数的情况下，Java编译器会为这个类创建一个默认的构造函数。</p>
<p>Java中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己唯一的参数列表。</p>
<p>Java不支持像C++中那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，Java不会创建默认的复制构造函数。</p>
<h3 id="第15题-Java支持多继承么？"><a href="#第15题-Java支持多继承么？" class="headerlink" title="[第15题] Java支持多继承么？"></a>[第15题] Java支持多继承么？</h3><p>不支持，Java不支持多继承。每个类都只能继承一个类，但是可以实现多个接口。</p>
<h3 id="第16题-接口和抽象类的区别是什么？"><a href="#第16题-接口和抽象类的区别是什么？" class="headerlink" title="[第16题] 接口和抽象类的区别是什么？"></a>[第16题] 接口和抽象类的区别是什么？</h3><p>Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：</p>
<p>接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。</p>
<p>类可以实现很多个接口，但是只能继承一个抽象类</p>
<p>类如果要实现一个接口，它必须要实现接口声明的所有方法。但是，类可以不实现抽象类声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。</p>
<p>抽象类可以在不提供接口方法实现的情况下实现接口。</p>
<p>Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。</p>
<p>Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。</p>
<p>接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。</p>
<p>也可以参考JDK8中抽象类和接口的区别</p>
<h3 id="第17题-10-什么是值传递和引用传递？"><a href="#第17题-10-什么是值传递和引用传递？" class="headerlink" title="[第17题] 10.什么是值传递和引用传递？"></a>[第17题] 10.什么是值传递和引用传递？</h3><p>对象被值传递，意味着传递了对象的一个副本。因此，就算是改变了对象副本，也不会影响源对象的值。</p>
<p>对象被引用传递，意味着传递的并不是实际的对象，而是对象的引用。因此，外部对引用对象所做的改变会反映到所有的对象上。</p>
<h3 id="第18题-我们能在-Switch-中使用-String-吗？"><a href="#第18题-我们能在-Switch-中使用-String-吗？" class="headerlink" title="[第18题] 我们能在 Switch 中使用 String 吗？"></a>[第18题] 我们能在 Switch 中使用 String 吗？</h3><p>从 Java 7 开始，我们可以在 switch case 中使用字符串，但这仅仅是一个语法糖。内部实现在 switch 中使用字符串的 hash code。</p>
<h3 id="第19题-20-Java-中的构造器链是什么？"><a href="#第19题-20-Java-中的构造器链是什么？" class="headerlink" title="[第19题] 20.Java 中的构造器链是什么？"></a>[第19题] 20.Java 中的构造器链是什么？</h3><p>当你从一个构造器中调用另一个构造器，就是Java 中的构造器链。这种情况只在重载了类的构造器的时候才会出现。</p>
<h3 id="第20题-64-位-JVM-中，int-的长度是多数？"><a href="#第20题-64-位-JVM-中，int-的长度是多数？" class="headerlink" title="[第20题] 64 位 JVM 中，int 的长度是多数？"></a>[第20题] 64 位 JVM 中，int 的长度是多数？</h3><p>Java 中，int 类型变量的长度是一个固定值，与平台无关，都是 32 位。意思就是说，在 32 位 和 64 位 的Java 虚拟机中，int 类型的长度是相同的。</p>
<p>[第21题]? 32 位和 64 位的 JVM，int 类型变量的长度是多数？</p>
<p>32 位和 64 位的 JVM 中，int 类型变量的长度是相同的，都是 32 位或者 4 个字节。</p>
<h3 id="第22题-“a-b”和”a-equals-b-”有什么区别？"><a href="#第22题-“a-b”和”a-equals-b-”有什么区别？" class="headerlink" title="[第22题]? “a==b”和”a.equals(b)”有什么区别？"></a>[第22题]? “a==b”和”a.equals(b)”有什么区别？</h3><p>如果 a 和 b 都是对象，则 a==b 是比较两个对象的引用，只有当 a 和 b 指向的是堆中的同一个对象才会返回 true，而 a.equals(b) 是进行逻辑比较，所以通常需要重写该方法来提供逻辑一致性的比较。例如，String 类重写 equals() 方法，所以可以用于两个不同对象，但是包含的字母相同的比较。</p>
<h3 id="第23题-a-hashCode-有什么用？与-a-equals-b-有什么关系？"><a href="#第23题-a-hashCode-有什么用？与-a-equals-b-有什么关系？" class="headerlink" title="[第23题] a.hashCode() 有什么用？与 a.equals(b) 有什么关系？"></a>[第23题] a.hashCode() 有什么用？与 a.equals(b) 有什么关系？</h3><p>hashCode() 方法是相应对象整型的 hash 值。它常用于基于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap等等。它与 equals() 方法关系特别紧密。根据 Java 规范，两个使用 equal() 方法来判断相等的对象，必须具有相同的 hash code。</p>
<h3 id="第24题-final、finalize-和-finally-的不同之处？"><a href="#第24题-final、finalize-和-finally-的不同之处？" class="headerlink" title="[第24题] final、finalize 和 finally 的不同之处？"></a>[第24题] final、finalize 和 finally 的不同之处？</h3><p>final 是一个修饰符，可以修饰变量、方法和类。如果 final 修饰变量，意味着该变量的值在初始化后不能被改变。finalize 方法是在对象被回收之前调用的方法，给对象自己最后一个复活的机会，但是什么时候调用 finalize 没有保证。finally 是一个关键字，与 try 和 catch 一起用于异常的处理。finally 块一定会被执行，无论在 try 块中是否有发生异常。</p>
<h3 id="第25题-Java-中的编译期常量是什么？使用它又什么风险？"><a href="#第25题-Java-中的编译期常量是什么？使用它又什么风险？" class="headerlink" title="[第25题] Java 中的编译期常量是什么？使用它又什么风险？"></a>[第25题] Java 中的编译期常量是什么？使用它又什么风险？</h3><p>公共静态不可变（public static final ）变量也就是我们所说的编译期常量，这里的 public 可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的jar。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。</p>
<h3 id="第26题-用最有效率的方法计算2乘以8？"><a href="#第26题-用最有效率的方法计算2乘以8？" class="headerlink" title="[第26题] 用最有效率的方法计算2乘以8？"></a>[第26题] 用最有效率的方法计算2乘以8？</h3><p>答： 2 &lt;&lt; 3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="/basic/java基础进阶细节/" data-id="ckzh6gugf0003nk97osgo9to3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web/">web</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/阅读/">阅读</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springboot/">springboot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web/">web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/悦读/">悦读</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技术/">技术</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/框架/">框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/游戏/">游戏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/自动化/">自动化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/自动化测试/">自动化测试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/资源/">资源</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/阅读/">阅读</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/python/" style="font-size: 13.33px;">python</a> <a href="/tags/springboot/" style="font-size: 10px;">springboot</a> <a href="/tags/web/" style="font-size: 20px;">web</a> <a href="/tags/悦读/" style="font-size: 13.33px;">悦读</a> <a href="/tags/技术/" style="font-size: 16.67px;">技术</a> <a href="/tags/框架/" style="font-size: 10px;">框架</a> <a href="/tags/游戏/" style="font-size: 10px;">游戏</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a> <a href="/tags/自动化/" style="font-size: 10px;">自动化</a> <a href="/tags/自动化测试/" style="font-size: 10px;">自动化测试</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a> <a href="/tags/资源/" style="font-size: 10px;">资源</a> <a href="/tags/阅读/" style="font-size: 16.67px;">阅读</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/null/小白算法记/">小白算法记</a>
          </li>
        
          <li>
            <a href="/sjms/设计模式-动态代理/">设计模式-动态代理</a>
          </li>
        
          <li>
            <a href="/springboot/springboot初体验/">springboot初体验</a>
          </li>
        
          <li>
            <a href="/hyrobort/hyrobort的使用/">hyrobort的使用</a>
          </li>
        
          <li>
            <a href="/selenium/selenium快速使用/">selenium快速使用</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 Shown Feng<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>